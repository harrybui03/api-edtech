<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Streaming Test</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .video-box {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        .video-box video {
            width: 100%;
            height: auto;
            display: block;
        }
        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .controls {
            margin-top: 10px;
        }
        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }
        .btn-group-sm .btn {
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <h1 class="mb-4">üé• Live Streaming Test</h1>
        
        <!-- Login Section -->
        <div class="section" id="login-section">
            <h3>üîê Authentication</h3>
            <div class="row g-3">
                <div class="col-md-5">
                    <label class="form-label">Access Token:</label>
                    <input type="text" id="accessToken" class="form-control" placeholder="Paste your access token">
                </div>
                <div class="col-md-5">
                    <label class="form-label">Refresh Token (optional):</label>
                    <input type="text" id="refreshToken" class="form-control" placeholder="Paste your refresh token">
                </div>
                <div class="col-md-2 d-flex align-items-end">
                    <button onclick="saveTokens()" class="btn btn-primary w-100">Save Tokens</button>
                </div>
            </div>
            <div class="mt-2">
                <small class="text-muted">Status: <span id="auth-status" class="badge bg-secondary">Not authenticated</span></small>
            </div>
        </div>

        <!-- Instructor Controls -->
        <div class="section">
            <h3>üë®‚Äçüè´ Instructor Controls</h3>
            <div class="row g-3">
                <div class="col-md-4">
                    <label class="form-label">Batch ID:</label>
                    <input type="text" id="batchId" class="form-control" placeholder="Enter batch UUID">
                </div>
                <div class="col-md-3">
                    <label class="form-label">Title:</label>
                    <input type="text" id="liveTitle" class="form-control" value="Live Session Test">
                </div>
                <div class="col-md-5">
                    <label class="form-label">Description:</label>
                    <input type="text" id="liveDescription" class="form-control" value="Testing live streaming">
                </div>
            </div>
            <div class="controls">
                <button onclick="startLive()" class="btn btn-success">Start Live</button>
                <button onclick="endLive()" class="btn btn-danger">End Live</button>
            </div>
            <div class="mt-2">
                <small>Room ID: <strong id="roomId">-</strong></small>
            </div>
        </div>

        <!-- Join & Publish Section -->
        <div class="section">
            <h3>üìπ Join Room & Publish Streams</h3>
            <div class="row g-3">
                <div class="col-md-6">
                    <label class="form-label">Room ID:</label>
                    <input type="text" id="joinRoomId" class="form-control" placeholder="Enter room ID">
                </div>
                <div class="col-md-6">
                    <label class="form-label">Your Name (optional):</label>
                    <input type="text" id="displayName" class="form-control" placeholder="Enter your name">
                </div>
            </div>
            
            <!-- Join Room Button -->
            <div class="controls mt-3">
                <button onclick="joinRoom()" class="btn btn-primary btn-lg">üö™ Join Room</button>
                <button onclick="leaveRoom()" class="btn btn-danger btn-lg">üö™ Leave Room</button>
                <small class="ms-2">Session: <span id="sessionStatus" class="badge bg-secondary">Not joined</span></small>
            </div>
            
            <!-- Publish Buttons -->
            <div class="controls mt-3">
                <button onclick="publishCamera()" class="btn btn-success">üìπ Publish Camera</button>
                <button onclick="publishScreen()" class="btn btn-info">üñ•Ô∏è Publish Screen</button>
                <button onclick="toggleMic()" id="micBtn" class="btn btn-secondary">üé§ Mute Mic</button>
                <button onclick="unpublishCamera()" class="btn btn-warning" id="stopCameraBtn">‚èπÔ∏è Stop Camera</button>
                <button onclick="unpublishScreen()" class="btn btn-warning">‚èπÔ∏è Stop Screen</button>
            </div>
            
            <div class="mt-2">
                <small>Room: <strong id="currentRoomId">-</strong></small> | 
                <small>Session: <strong id="mainSessionId">-</strong></small> | 
                <small>Mic: <span id="micStatus" class="badge bg-success">ON</span></small>
            </div>
            <p class="text-muted mt-2 mb-0">
                <small>üí° <strong>Best practice:</strong> Join room first ‚Üí Then publish camera/screen</small><br>
                <small>üî• All operations (join, publish, subscribe) use the same session!</small>
            </p>
        </div>

        <!-- Recording Controls (Instructor) -->
        <div class="section">
            <h3>üé¨ Recording Controls (Instructor)</h3>
            <div class="alert alert-info">
                <strong>üìù How it works:</strong> Records your screen + mic + system audio ‚Üí Creates 30-second chunks ‚Üí Auto-uploads to backend ‚Üí Backend merges & transcodes
            </div>
            <div class="controls">
                <button onclick="startRecording()" id="startRecBtn" class="btn btn-danger btn-lg">üî¥ Start Recording</button>
                <button onclick="stopRecording()" id="stopRecBtn" class="btn btn-warning btn-lg" disabled>‚èπÔ∏è Stop Recording</button>
                <button onclick="checkRecordingStatus()" class="btn btn-info">üìä Check Status</button>
            </div>
            <div class="mt-3">
                <div class="row">
                    <div class="col-md-3">
                        <small>Status: <span id="recStatus" class="badge bg-secondary">Not Started</span></small>
                    </div>
                    <div class="col-md-3">
                        <small>Duration: <strong id="recDuration">00:00</strong></small>
                    </div>
                    <div class="col-md-3">
                        <small>Chunks: <strong id="recChunks">0</strong></small>
                    </div>
                    <div class="col-md-3">
                        <small>Last Upload: <span id="recLastUpload">-</span></small>
                    </div>
                </div>
            </div>
            <div id="recordingProgress" class="mt-3" style="display:none;">
                <div class="progress">
                    <div id="uploadProgress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%">Uploading...</div>
                </div>
            </div>
            <div id="recordingResult" class="mt-3"></div>
        </div>

        <!-- Watch Others -->
        <div class="section">
            <h3>üëÄ Watch Others</h3>
            <div class="controls">
                <button onclick="listParticipants()" class="btn btn-primary">List Participants</button>
                <button onclick="subscribeToAll()" class="btn btn-success">Subscribe to All</button>
            </div>
            <div id="participantsList" class="mt-3"></div>
        </div>

        <!-- Video Display -->
        <div class="section">
            <h3>üì∫ Video Streams</h3>
            <div class="video-container" id="videoContainer">
                <!-- Videos will be added here dynamically -->
            </div>
        </div>

        <!-- Logs -->
        <div class="section">
            <h3>üìã Logs</h3>
            <div class="log-container" id="logContainer"></div>
            <button onclick="clearLogs()" class="btn btn-sm btn-secondary mt-2">Clear Logs</button>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000/api/v1';
        let accessToken = '';
        let refreshToken = '';
        
        // ==========================================
        // üî• WebRTC Utilities (based on janus.js patterns)
        // Reference: https://janus.conf.meetecho.com/docs/videoroom
        // ==========================================
        
        /**
         * Default ICE servers configuration
         * Similar to janus.js iceServers default
         */
        const DEFAULT_ICE_SERVERS = [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' }
        ];
        
        /**
         * Create a PeerConnection with standard config
         * Similar to janus.js createPeerconnectionIfNeeded()
         * @param {Object} options - Additional RTCPeerConnection options
         * @returns {RTCPeerConnection}
         */
        function createPeerConnection(options = {}) {
            const pcConfig = {
                iceServers: options.iceServers || DEFAULT_ICE_SERVERS,
                sdpSemantics: 'unified-plan',  // Modern WebRTC (janus.js uses this)
                iceCandidatePoolSize: options.iceCandidatePoolSize || 10,
                ...options.config
            };
            
            return new RTCPeerConnection(pcConfig);
        }
        
        /**
         * Create SDP offer and wait for ICE gathering
         * Similar to janus.js createOffer() + sendSDP()
         * 
         * @param {RTCPeerConnection} pc - PeerConnection
         * @param {Object} options - Offer options
         * @returns {Promise<{type: string, sdp: string}>} - Complete offer with ICE candidates
         */
        async function createOfferWithIce(pc, options = {}) {
            const offerOptions = {
                offerToReceiveAudio: options.receiveAudio ?? false,
                offerToReceiveVideo: options.receiveVideo ?? false,
                iceRestart: options.iceRestart ?? false
            };
            
            // Create offer
            const offer = await pc.createOffer(offerOptions);
            await pc.setLocalDescription(offer);
            
            // Wait for ICE gathering (like janus.js when trickle=false)
            const timeout = options.timeout || 10000;
            const sdp = await waitForIceGathering(pc, timeout);
            
            return {
                type: 'offer',
                sdp: sdp
            };
        }
        
        /**
         * Create SDP answer and wait for ICE gathering
         * Similar to janus.js createAnswer()
         * 
         * @param {RTCPeerConnection} pc - PeerConnection (must have remote description set)
         * @param {Object} options - Answer options
         * @returns {Promise<{type: string, sdp: string}>} - Complete answer with ICE candidates
         */
        async function createAnswerWithIce(pc, options = {}) {
            // Create answer
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            // Wait for ICE gathering
            const timeout = options.timeout || 10000;
            const sdp = await waitForIceGathering(pc, timeout);
            
            return {
                type: 'answer',
                sdp: sdp
            };
        }
        
        /**
         * Wait for ICE gathering to complete
         * Returns the final SDP with all ICE candidates
         * 
         * Based on janus.js pattern: wait for null candidate or gathering state complete
         * 
         * @param {RTCPeerConnection} pc - PeerConnection
         * @param {number} timeout - Max time to wait in ms (default 10000)
         * @returns {Promise<string>} - Final SDP with ICE candidates
         */
        function waitForIceGathering(pc, timeout = 10000) {
            return new Promise((resolve) => {
                // Already complete
                if (pc.iceGatheringState === 'complete') {
                    resolve(pc.localDescription.sdp);
                    return;
                }
                
                let candidateCount = 0;
                
                // Timeout handler
                const timeoutId = setTimeout(() => {
                    log(`‚ö†Ô∏è ICE gathering timeout (${candidateCount} candidates)`);
                    resolve(pc.localDescription.sdp);
                }, timeout);
                
                // ICE candidate handler (janus.js pattern)
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        candidateCount++;
                        // Candidate found - continue gathering
                    } else {
                        // Null candidate = end of candidates (janus.js endOfCandidates)
                        clearTimeout(timeoutId);
                        log(`‚úÖ ICE gathering done (${candidateCount} candidates)`);
                        resolve(pc.localDescription.sdp);
                    }
                };
                
                // Also listen for state change
                pc.onicegatheringstatechange = () => {
                    if (pc.iceGatheringState === 'complete') {
                        clearTimeout(timeoutId);
                        resolve(pc.localDescription.sdp);
                    }
                };
            });
        }
        
        /**
         * Validate SDP before sending to Janus
         * Checks for common issues that cause errors
         * 
         * @param {string} sdp - SDP string
         * @returns {{valid: boolean, warnings: string[]}}
         */
        function validateSdp(sdp) {
            const warnings = [];
            
            // Check for 0.0.0.0 without ICE candidates (causes Janus error 490)
            if (sdp.includes('c=IN IP4 0.0.0.0') && !sdp.includes('a=candidate:')) {
                warnings.push('SDP has 0.0.0.0 and NO ICE candidates - will fail!');
            }
            
            // Check for ICE credentials
            if (!sdp.includes('a=ice-ufrag:') || !sdp.includes('a=ice-pwd:')) {
                warnings.push('Missing ICE credentials (ufrag/pwd)');
            }
            
            // Check for fingerprint (DTLS)
            if (!sdp.includes('a=fingerprint:')) {
                warnings.push('Missing DTLS fingerprint');
            }
            
            return {
                valid: warnings.length === 0,
                warnings: warnings
            };
        }
        
        /**
         * Setup standard event handlers for PeerConnection
         * Similar to janus.js plugin handle callbacks
         * 
         * @param {RTCPeerConnection} pc 
         * @param {string} name - Name for logging
         */
        function setupPcEventHandlers(pc, name) {
            pc.oniceconnectionstatechange = () => {
                const state = pc?.iceConnectionState;
                log(`üîå [${name}] ICE: ${state}`);
                if (state === 'failed') {
                    log(`‚ùå [${name}] ICE FAILED!`);
                }
            };
            
            pc.onconnectionstatechange = () => {
                log(`üîó [${name}] Connection: ${pc?.connectionState}`);
            };
            
            pc.onsignalingstatechange = () => {
                log(`üì° [${name}] Signaling: ${pc?.signalingState}`);
            };
        }
        
        // State management - NEW ARCHITECTURE: 1 Session - Multiple Handles
        let state = {
            roomId: null,
            mainSessionId: null,  // üî• ONE main session for all (join, publish, subscribe)
            // Peer connections
            cameraPc: null,
            cameraHandleId: null,
            screenPc: null,
            screenHandleId: null,
            screenStream: null,   // Screen share stream
            subscriberPcs: {},
            subscriberHandles: {},  // Track subscriber handles
            publishers: [],
            keepaliveTimer: null,  // üî• ONE keepalive timer for main session
            micMuted: false,
            localStream: null,    // Camera stream
            // Recording state
            recording: {
                mediaRecorder: null,
                combinedStream: null,
                chunkIndex: 0,
                isRecording: false,
                isStopping: false, // Flag to prevent restart on stop
                startTime: null,
                durationTimer: null,
                chunkTimer: null, // Timer for stop/restart every 30s
                totalDurationSeconds: 0,
                uploadedChunks: 0,
                screenStream: null,
                micStream: null,
                audioContext: null,
                roomId: null,
                isCompleting: false, // Flag to prevent duplicate complete API calls
                recordingOptions: null, // Store MediaRecorder options for restart
                recordingStream: null // Store stream for restart
            }
        };

        // ===== Authentication =====
        function saveTokens() {
            accessToken = document.getElementById('accessToken').value.trim();
            refreshToken = document.getElementById('refreshToken').value.trim();
            
            if (accessToken) {
                document.getElementById('auth-status').textContent = 'Authenticated';
                document.getElementById('auth-status').className = 'badge bg-success';
                log('‚úÖ Tokens saved successfully');
            } else {
                document.getElementById('auth-status').textContent = 'Not authenticated';
                document.getElementById('auth-status').className = 'badge bg-danger';
                log('‚ùå Please enter access token');
            }
        }

        function getHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            };
        }

        // ===== Logging =====
        function log(message) {
            const logContainer = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            logContainer.innerHTML += `[${time}] ${message}\n`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('logContainer').innerHTML = '';
        }

        // ===== Video Management =====
        function addVideoElement(streamId, stream, label) {
            const container = document.getElementById('videoContainer');
            
            // Remove existing video if any
            const existing = document.getElementById(streamId);
            if (existing) {
                existing.remove();
            }
            
            const videoBox = document.createElement('div');
            videoBox.className = 'video-box';
            videoBox.id = streamId;
            
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsinline = true;
            video.muted = label.includes('Local'); // Mute local videos
            video.srcObject = stream;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'video-label';
            labelDiv.textContent = label;
            
            videoBox.appendChild(video);
            videoBox.appendChild(labelDiv);
            container.appendChild(videoBox);
            
            log(`üìπ Added video: ${label}`);
        }

        function removeVideoElement(streamId) {
            const element = document.getElementById(streamId);
            if (element) {
                element.remove();
                log(`üóëÔ∏è Removed video: ${streamId}`);
            }
        }

        // ===== Start Live (Instructor) =====
        async function startLive() {
            const batchId = document.getElementById('batchId').value.trim();
            const title = document.getElementById('liveTitle').value.trim();
            const description = document.getElementById('liveDescription').value.trim();
            
            if (!batchId) {
                alert('Please enter batch ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/start`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ batchId, title, description })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    state.roomId = data.roomId;
                    document.getElementById('roomId').textContent = data.roomId;
                    document.getElementById('joinRoomId').value = data.roomId;
                    log(`‚úÖ Live started! Room ID: ${data.roomId}`);
                } else {
                    log(`‚ùå Start live failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
            }
        }

        // ===== End Live =====
        async function endLive() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/end/${roomId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`‚úÖ Live ended successfully`);
                } else {
                    log(`‚ùå End live failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
            }
        }

        // ===== Join Room =====
        async function joinRoom() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            const displayName = document.getElementById('displayName').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const requestBody = { 
                    roomId: parseInt(roomId), 
                    ptype: 'publisher',  // Always join as publisher
                    displayName: displayName || undefined
                };
                
                const response = await fetch(`${API_BASE}/live/join`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // üî• Save main session ID - will be reused for ALL operations
                    state.mainSessionId = data.sessionId;
                    state.roomId = parseInt(roomId);
                    
                    // Update UI
                    document.getElementById('currentRoomId').textContent = roomId;
                    document.getElementById('mainSessionId').textContent = state.mainSessionId;
                    document.getElementById('sessionStatus').textContent = 'Joined ‚úÖ';
                    document.getElementById('sessionStatus').className = 'badge bg-success';
                    
                    // Start keepalive for main session
                    startKeepalive(state.mainSessionId);
                    
                    const name = displayName || 'Anonymous';
                    log(`‚úÖ Joined room ${roomId} as publisher (${name})`);
                    log(`üî• Main session created: ${state.mainSessionId}`);
                    log(`üí° This session will be reused for camera, screen, and subscribe!`);
                } else {
                    log(`‚ùå Join failed: ${JSON.stringify(data)}`);
                    document.getElementById('sessionStatus').textContent = 'Failed ‚ùå';
                    document.getElementById('sessionStatus').className = 'badge bg-danger';
                }
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
            }
        }

        // ===== Publish Camera =====
        // üî• Implementation based on janus.js library pattern
        // Reference: https://janus.conf.meetecho.com/docs/videoroom
        async function publishCamera() {
            const roomId = state.roomId || document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please join room first or enter room ID');
                return;
            }
            
            if (!state.roomId) {
                state.roomId = parseInt(roomId);
            }
            
            // Cleanup existing resources
            if (state.cameraPc) {
                log('‚ö†Ô∏è Cleaning up existing camera PeerConnection...');
                state.cameraPc.close();
                state.cameraPc = null;
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            if (state.localStream) {
                state.localStream.getTracks().forEach(track => track.stop());
                state.localStream = null;
            }
            
            try {
                // ==========================================
                // Step 1: Get camera stream (getUserMedia)
                // Similar to janus.js captureDevices()
                // ==========================================
                log('üìπ Requesting camera access...');
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: { ideal: 1280 }, height: { ideal: 720 } }, 
                    audio: true 
                });
                state.localStream = stream;
                addVideoElement('local-camera', stream, 'Local Camera');
                log('‚úÖ Camera stream obtained');
                
                // ==========================================
                // Step 2: Create PeerConnection
                // Using utility function (janus.js pattern)
                // ==========================================
                log('üì° Creating PeerConnection...');
                state.cameraPc = createPeerConnection();
                
                // Setup event handlers
                setupPcEventHandlers(state.cameraPc, 'Camera');
                
                // ==========================================
                // Step 3: Add tracks to PeerConnection
                // ==========================================
                stream.getTracks().forEach(track => {
                    log(`   Adding ${track.kind} track: ${track.label}`);
                    state.cameraPc.addTrack(track, stream);
                });
                
                // ==========================================
                // Step 4: Create Offer with ICE gathering
                // Using utility function (janus.js createOffer + waitForIceGathering)
                // ==========================================
                log('üìù Creating SDP offer...');
                const offer = await createOfferWithIce(state.cameraPc, {
                    receiveAudio: false,  // Publisher only sends
                    receiveVideo: false,
                    timeout: 10000
                });
                
                // ==========================================
                // Step 5: Validate SDP
                // ==========================================
                const validation = validateSdp(offer.sdp);
                log(`üìä SDP stats: audio=${offer.sdp.includes('m=audio')}, video=${offer.sdp.includes('m=video')}`);
                log(`üìä ICE candidates: ${(offer.sdp.match(/a=candidate:/g) || []).length}`);
                
                if (!validation.valid) {
                    log('‚ö†Ô∏è SDP validation warnings:');
                    validation.warnings.forEach(w => log(`   - ${w}`));
                    
                    const proceed = confirm('SDP has issues. Try anyway?');
                    if (!proceed) {
                        log('‚ùå Publish cancelled');
                        return;
                    }
                }
                
                // ==========================================
                // Step 6: Send to Janus via backend
                // VideoRoom API: publish with jsep
                // ==========================================
                log('üì§ Sending publish request...');
                document.getElementById('currentRoomId').textContent = roomId;
                
                const response = await fetch(`${API_BASE}/live/publish`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ 
                        roomId: parseInt(roomId), 
                        sdp: offer.sdp,
                        streamType: 'camera'
                    })
                });
                
                const data = await response.json();
                
                // ==========================================
                // Step 7: Process Janus response
                // Handle SDP answer (janus.js handleRemoteJsep)
                // ==========================================
                if (response.ok && data.sdpAnswer) {
                    log('üì• Received SDP answer from Janus');
                    
                    // Save session/handle info
                    if (data.sessionId && data.handleId) {
                        const isNewSession = !state.mainSessionId || data.sessionId !== state.mainSessionId;
                        state.mainSessionId = data.sessionId;
                        state.cameraHandleId = data.handleId;
                        
                        if (isNewSession) {
                            startKeepalive(state.mainSessionId);
                        }
                        log(`üìä Session: ${state.mainSessionId}, Handle: ${state.cameraHandleId}`);
                    }
                    
                    // Set remote description (SDP answer)
                    if (state.cameraPc.signalingState !== 'have-local-offer') {
                        throw new Error(`Invalid signaling state: ${state.cameraPc.signalingState}`);
                    }
                    
                    await state.cameraPc.setRemoteDescription(new RTCSessionDescription({
                        type: 'answer',
                        sdp: data.sdpAnswer
                    }));
                    
                    log('‚úÖ Camera published successfully!');
                    
                } else if (data.error) {
                    log(`‚ùå Publish failed: ${data.error} (code: ${data.errorCode})`);
                    
                    // VideoRoom error codes reference
                    const errorHints = {
                        490: 'ICE failed - check STUN/TURN servers',
                        432: 'No such room',
                        433: 'Room is full',
                        436: 'No such feed'
                    };
                    if (errorHints[data.errorCode]) {
                        log(`üí° ${errorHints[data.errorCode]}`);
                    }
                } else {
                    log(`‚ùå Unexpected response: ${JSON.stringify(data)}`);
                }
                
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                console.error('Publish camera error:', error);
            }
        }

        // ===== Publish Screen =====
        // üî• Implementation based on janus.js library pattern
        async function publishScreen() {
            const roomId = state.roomId || document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please join room first or enter room ID');
                return;
            }
            
            if (!state.roomId) {
                state.roomId = parseInt(roomId);
            }
            
            // Cleanup existing resources
            if (state.screenPc) {
                log('‚ö†Ô∏è Cleaning up existing screen PeerConnection...');
                state.screenPc.close();
                state.screenPc = null;
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            if (state.screenStream) {
                state.screenStream.getTracks().forEach(track => track.stop());
                state.screenStream = null;
            }
            
            try {
                // Step 1: Get screen stream (getDisplayMedia)
                log('üñ•Ô∏è Requesting screen share...');
                const stream = await navigator.mediaDevices.getDisplayMedia({ 
                    video: { width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } }, 
                    audio: true
                });
                
                state.screenStream = stream;
                addVideoElement('local-screen', stream, 'Local Screen');
                log('‚úÖ Screen stream obtained');
                
                // Handle user stops sharing via browser button
                stream.getVideoTracks()[0].onended = () => {
                    log('‚ö†Ô∏è Screen sharing stopped by user');
                    if (state.screenHandleId) {
                        unpublishScreen();
                    } else {
                        removeVideoElement('local-screen');
                        state.screenStream = null;
                    }
                };
                
                // Step 2: Create PeerConnection (using utility)
                log('üì° Creating Screen PeerConnection...');
                state.screenPc = createPeerConnection();
                setupPcEventHandlers(state.screenPc, 'Screen');
                
                // Step 3: Add tracks
                stream.getTracks().forEach(track => {
                    log(`   Adding ${track.kind} track: ${track.label}`);
                    state.screenPc.addTrack(track, stream);
                });
                
                // Step 4: Create Offer with ICE (using utility)
                log('üìù Creating screen SDP offer...');
                const offer = await createOfferWithIce(state.screenPc, {
                    receiveAudio: false,
                    receiveVideo: false,
                    timeout: 10000
                });
                
                log(`üìä Screen SDP: audio=${offer.sdp.includes('m=audio')}, video=${offer.sdp.includes('m=video')}`);
                
                // Step 5: Send to Janus
                log('üì§ Publishing screen share...');
                const response = await fetch(`${API_BASE}/live/publish-screen`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ roomId: parseInt(roomId), sdp: offer.sdp })
                });
                
                const data = await response.json();
                
                // Step 6: Process response
                if (response.ok && data.sdpAnswer) {
                    if (data.sessionId && data.handleId) {
                        const isNewSession = !state.mainSessionId || data.sessionId !== state.mainSessionId;
                        state.mainSessionId = data.sessionId;
                        state.screenHandleId = data.handleId;
                        if (isNewSession) startKeepalive(state.mainSessionId);
                    }
                    
                    await state.screenPc.setRemoteDescription(new RTCSessionDescription({
                        type: 'answer',
                        sdp: data.sdpAnswer
                    }));
                    
                    log(`‚úÖ Screen published! Handle: ${state.screenHandleId}`);
                } else {
                    log(`‚ùå Publish screen failed: ${data.error || JSON.stringify(data)}`);
                }
                
            } catch (error) {
                log(`‚ùå Screen error: ${error.message}`);
                console.error('Publish screen error:', error);
            }
        }

        // ===== Unpublish Camera =====
        async function unpublishCamera() {
            console.log('üî¥ unpublishCamera() called!'); // Debug
            log('üî¥ unpublishCamera button clicked');
            
            if (!state.roomId) {
                const msg = 'Please join room first';
                alert(msg);
                log(`‚ùå Validation failed: ${msg}`);
                return;
            }
            
            const roomId = state.roomId;
            log(`üîç Room ID: ${roomId}`);
            
            // Validate we have session and handle IDs
            if (!state.mainSessionId || !state.cameraHandleId) {
                const msg = 'Camera not published (missing session/handle ID)';
                alert(msg);
                log(`‚ùå ${msg}`);
                return;
            }
            
            try {
                log('üõë Stopping camera...');
                
                // üî• IMPORTANT: Call backend FIRST, before closing PeerConnection!
                // If we close PeerConnection first, Janus detects "No WebRTC media"
                // and auto-unpublishes, causing "Can't unpublish, not published" error
                
                // Step 1: Notify backend with sessionId + handleId (BEFORE closing PC!)
                log(`   Sending unpublish request (session: ${state.mainSessionId}, handle: ${state.cameraHandleId})...`);
                const response = await fetch(`${API_BASE}/live/unpublish`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        roomId: parseInt(roomId),
                        sessionId: state.mainSessionId,
                        handleId: state.cameraHandleId
                    })
                });
                
                const data = await response.json();
                
                if (response.ok || data.janus === 'success') {
                    log('‚úÖ Backend unpublish successful');
                } else {
                    log(`‚ö†Ô∏è Backend unpublish had issues: ${data.error || 'Unknown'}, continuing cleanup...`);
                }
                
                // Step 2: Now safe to stop local stream tracks (turns off camera LED)
                if (state.localStream) {
                    log('   Stopping local stream tracks...');
                    state.localStream.getTracks().forEach(track => {
                        log(`   - Stopping ${track.kind} track (id: ${track.id})`);
                        track.stop();
                    });
                    state.localStream = null;
                }
                
                // Step 3: Close peer connection (AFTER backend unpublish!)
                if (state.cameraPc) {
                    log('   Closing peer connection...');
                    state.cameraPc.close();
                    state.cameraPc = null;
                }
                
                // Step 4: Remove video element
                removeVideoElement('local-camera');
                
                // Step 5: Reset mic state ONLY if no other streams are active
                if (!state.screenHandleId) {
                    state.micMuted = false;
                    document.getElementById('micBtn').textContent = 'üé§ Mute Mic';
                    document.getElementById('micBtn').className = 'btn btn-secondary';
                    document.getElementById('micStatus').textContent = 'ON';
                    document.getElementById('micStatus').className = 'badge bg-success';
                    log('   Mic state reset (no other streams active)');
                } else {
                    log('   Keeping mic state (screen share still active)');
                }
                
                // Step 6: Clear handle state
                state.cameraHandleId = null;
                
                // Small delay to ensure Janus has processed the detach
                await new Promise(resolve => setTimeout(resolve, 200));
                
                log('‚úÖ Camera unpublished and cleaned up successfully');
                
            } catch (error) {
                log(`‚ùå Error in unpublishCamera: ${error.message}`);
                console.error('‚ùå Unpublish error:', error);
                
                // Even on error, cleanup local resources
                if (state.localStream) {
                    state.localStream.getTracks().forEach(track => track.stop());
                    state.localStream = null;
                }
                if (state.cameraPc) {
                    state.cameraPc.close();
                    state.cameraPc = null;
                }
                removeVideoElement('local-camera');
                state.cameraHandleId = null;
                
                alert(`Error stopping camera: ${error.message}`);
            }
            
            console.log('üî¥ unpublishCamera() finished');
        }

        // ===== Unpublish Screen =====
        async function unpublishScreen() {
            if (!state.roomId) {
                alert('Please join room first');
                return;
            }
            
            const roomId = state.roomId;
            
            // Validate we have session and handle IDs
            if (!state.mainSessionId || !state.screenHandleId) {
                alert('Screen not published (missing session/handle ID)');
                log('‚ùå Screen not published (missing session/handle ID)');
                return;
            }
            
            try {
                log('üõë Stopping screen share...');
                
                // üî• IMPORTANT: Call backend FIRST, before closing PeerConnection!
                // Same reason as unpublishCamera - avoid "Can't unpublish, not published" error
                
                // Step 1: Notify backend with sessionId + handleId (BEFORE closing PC!)
                log(`   Sending unpublish request (session: ${state.mainSessionId}, handle: ${state.screenHandleId})...`);
                const response = await fetch(`${API_BASE}/live/unpublish-screen`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        roomId: parseInt(roomId),
                        sessionId: state.mainSessionId,
                        handleId: state.screenHandleId
                    })
                });
                
                const data = await response.json();
                
                if (response.ok || data.janus === 'success') {
                    log('‚úÖ Backend unpublish screen successful');
                } else {
                    log(`‚ö†Ô∏è Backend unpublish screen had issues: ${data.error || 'Unknown'}, continuing cleanup...`);
                }
                
                // Step 2: Stop screen stream tracks
                if (state.screenStream) {
                    log('   Stopping screen stream tracks...');
                    state.screenStream.getTracks().forEach(track => track.stop());
                    state.screenStream = null;
                }
                
                // Step 3: Close peer connection
                if (state.screenPc) {
                    log('   Closing screen peer connection...');
                    state.screenPc.close();
                    state.screenPc = null;
                }
                
                // Step 4: Remove video element
                removeVideoElement('local-screen');
                
                // Step 5: Clear handle state
                state.screenHandleId = null;
                
                // Small delay to ensure Janus has processed the detach
                await new Promise(resolve => setTimeout(resolve, 200));
                
                log('‚úÖ Screen share unpublished and cleaned up successfully');
                
            } catch (error) {
                log(`‚ùå Error in unpublishScreen: ${error.message}`);
                console.error('Unpublish screen error:', error);
                
                // Even on error, cleanup local resources
                if (state.screenStream) {
                    state.screenStream.getTracks().forEach(track => track.stop());
                    state.screenStream = null;
                }
                if (state.screenPc) {
                    state.screenPc.close();
                    state.screenPc = null;
                }
                removeVideoElement('local-screen');
                state.screenHandleId = null;
            }
        }

        // ===== Toggle Microphone =====
        function toggleMic() {
            if (!state.localStream) {
                alert('Please publish camera first');
                log('‚ö†Ô∏è No local stream available. Publish camera first.');
                return;
            }
            
            const audioTracks = state.localStream.getAudioTracks();
            if (audioTracks.length === 0) {
                alert('No audio track found');
                log('‚ö†Ô∏è No audio track in local stream');
                return;
            }
            
            state.micMuted = !state.micMuted;
            audioTracks.forEach(track => {
                track.enabled = !state.micMuted;
            });
            
            // Update UI
            const micBtn = document.getElementById('micBtn');
            const micStatus = document.getElementById('micStatus');
            
            if (state.micMuted) {
                micBtn.textContent = 'üé§ Unmute Mic';
                micBtn.className = 'btn btn-danger';
                micStatus.textContent = 'OFF';
                micStatus.className = 'badge bg-danger';
                log('üîá Microphone muted');
            } else {
                micBtn.textContent = 'üé§ Mute Mic';
                micBtn.className = 'btn btn-secondary';
                micStatus.textContent = 'ON';
                micStatus.className = 'badge bg-success';
                log('üîä Microphone unmuted');
            }
        }

        // ===== List Participants =====
        async function listParticipants() {
            if (!state.roomId) {
                alert('Please join room first');
                return;
            }
            
            const roomId = state.roomId;
            
            try {
                // Backend automatically filters out all YOUR feeds (camera + screen)
                // No need to manually exclude - it uses your auth token to identify you!
                const url = `${API_BASE}/live/participants-feeds/${roomId}`;
                
                const response = await fetch(url, {
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    state.publishers = data.participants.filter(p => p.publisher);
                    
                    const container = document.getElementById('participantsList');
                    container.innerHTML = '<h5>üåê Active Streams (Others):</h5>';
                    
                    if (state.publishers.length === 0) {
                        container.innerHTML += '<p class="text-muted">No one else is streaming</p>';
                    }
                    
                    state.publishers.forEach(p => {
                        // Identify feed type by display name
                        const isScreen = p.display && p.display.includes('(Screen)');
                        const icon = isScreen ? 'üñ•Ô∏è' : 'üìπ';
                        
                        container.innerHTML += `
                            <div class="alert alert-info">
                                ${icon} <strong>${p.display}</strong> (Feed ID: ${p.id})
                                <button onclick="subscribeToPublisher(${p.id}, '${p.display}')" class="btn btn-sm btn-primary float-end">Watch</button>
                            </div>
                        `;
                    });
                    
                    log(`‚úÖ Found ${state.publishers.length} active stream(s) from others (your feeds auto-excluded)`);
                } else {
                    log(`‚ùå List participants failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
            }
        }
        
        // ===== Get My Feeds (Optional - for debugging) =====
        async function getMyFeeds() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/my-feeds/${roomId}`, {
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`üìä My Feeds: ${JSON.stringify(data.feeds, null, 2)}`);
                    
                    if (data.feeds && data.feeds.length > 0) {
                        log(`‚úÖ You have ${data.feeds.length} active feed(s):`);
                        data.feeds.forEach(feed => {
                            log(`   - ${feed.feedType}: Feed ID ${feed.feedId} (${feed.displayName})`);
                        });
                    } else {
                        log(`‚ÑπÔ∏è You have no active feeds in this room`);
                    }
                } else {
                    log(`‚ùå Get my feeds failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
            }
        }

        // ===== Subscribe to Publisher =====
        // üî• Implementation based on janus.js createAnswer pattern
        // Subscriber flow: receive offer from Janus ‚Üí create answer ‚Üí send back
        async function subscribeToPublisher(feedId, displayName) {
            if (!state.roomId) {
                alert('Please join room first');
                return;
            }
            
            const roomId = state.roomId;
            
            try {
                log(`üëÄ Subscribing to ${displayName} (feed ${feedId})...`);
                
                // Step 1: Request subscription from backend
                const subscribeResponse = await fetch(`${API_BASE}/live/subscribe`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ roomId: parseInt(roomId), feedId: feedId })
                });
                
                const subscribeData = await subscribeResponse.json();
                
                if (!subscribeResponse.ok || !subscribeData.sdpOffer) {
                    log(`‚ùå Subscribe failed: ${subscribeData.error || JSON.stringify(subscribeData)}`);
                    return;
                }
                
                log(`üì• Received SDP offer from Janus`);
                log(`üìä Session: ${subscribeData.sessionId}, Handle: ${subscribeData.handleId}`);
                
                // Step 2: Create PeerConnection (using utility)
                const pc = createPeerConnection();
                state.subscriberPcs[feedId] = pc;
                
                // Step 3: Setup track handler (janus.js onremotetrack)
                pc.ontrack = (event) => {
                    log(`üé¨ Remote track: ${event.track.kind}`);
                    const [stream] = event.streams;
                    if (stream) {
                        addVideoElement(`remote-${feedId}`, stream, `Remote: ${displayName}`);
                        
                        event.track.onended = () => log(`‚ö†Ô∏è Track ended: ${event.track.kind}`);
                        event.track.onmute = () => log(`üîá Track muted: ${event.track.kind}`);
                        event.track.onunmute = () => log(`üîä Track unmuted: ${event.track.kind}`);
                    }
                };
                
                // Setup event handlers
                setupPcEventHandlers(pc, `Sub-${displayName}`);
                
                // Step 4: Set Remote Description (SDP offer from Janus)
                log('üìù Setting remote description...');
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: subscribeData.sdpOffer
                }));
                
                // Step 5: Create Answer with ICE (using utility)
                log('üìù Creating SDP answer...');
                const answer = await createAnswerWithIce(pc, { timeout: 10000 });
                
                // Step 6: Send SDP answer to Janus
                log('üì§ Sending SDP answer...');
                const startResponse = await fetch(`${API_BASE}/live/start-subscriber`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        sessionId: subscribeData.sessionId,
                        handleId: subscribeData.handleId,
                        sdpAnswer: answer.sdp
                    })
                });
                
                if (startResponse.ok) {
                    log(`‚úÖ Subscribed to ${displayName}!`);
                    state.mainSessionId = subscribeData.sessionId;
                    state.subscriberHandles[feedId] = subscribeData.handleId;
                } else {
                    const errorData = await startResponse.json();
                    log(`‚ùå Start subscriber failed: ${errorData.error || JSON.stringify(errorData)}`);
                }
                
            } catch (error) {
                log(`‚ùå Subscribe error: ${error.message}`);
                console.error('Subscribe error:', error);
            }
        }

        // ===== Subscribe to All Publishers =====
        async function subscribeToAll() {
            if (state.publishers.length === 0) {
                alert('Please list participants first');
                return;
            }
            
            for (const publisher of state.publishers) {
                await subscribeToPublisher(publisher.id, publisher.display);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Delay between subscriptions
            }
        }
        
        // ===== Unsubscribe from Feed =====
        /**
         * Cleanup subscriber connection for a specific feed
         * Called when a publisher leaves or stops publishing
         */
        function unsubscribeFromFeed(feedId) {
            log(`üîå Unsubscribing from feed ${feedId}...`);
            
            // Close peer connection
            const pc = state.subscriberPcs[feedId];
            if (pc) {
                pc.close();
                delete state.subscriberPcs[feedId];
                log(`   Peer connection closed for feed ${feedId}`);
            }
            
            // Remove handle tracking
            if (state.subscriberHandles[feedId]) {
                delete state.subscriberHandles[feedId];
                log(`   Handle removed for feed ${feedId}`);
            }
            
            // Remove video element
            removeVideoElement(`remote-${feedId}`);
            
            log(`‚úÖ Unsubscribed from feed ${feedId}`);
        }
        
        // ===== Cleanup All Subscribers =====
        /**
         * Cleanup all subscriber connections
         * Called when leaving room or on cleanup
         */
        function cleanupAllSubscribers() {
            const feedIds = Object.keys(state.subscriberPcs);
            if (feedIds.length > 0) {
                log(`üßπ Cleaning up ${feedIds.length} subscriber(s)...`);
                feedIds.forEach(feedId => unsubscribeFromFeed(feedId));
            }
        }

        // ===== State Management & Cleanup =====
        
        /**
         * Check if user is in a room
         */
        function isInRoom() {
            return state.roomId !== null && state.mainSessionId !== null;
        }
        
        /**
         * Cleanup all state and resources
         */
        function cleanupState() {
            log('üßπ Cleaning up state...');
            
            // Stop keepalive timer
            stopKeepalive();
            
            // Close camera peer connection
            if (state.cameraPc) {
                state.cameraPc.getSenders().forEach(sender => {
                    if (sender.track) sender.track.stop();
                });
                state.cameraPc.close();
                state.cameraPc = null;
            }
            
            // Stop screen stream
            if (state.screenStream) {
                state.screenStream.getTracks().forEach(track => track.stop());
                state.screenStream = null;
            }
            
            // Close screen peer connection
            if (state.screenPc) {
                state.screenPc.close();
                state.screenPc = null;
            }
            
            // Close all subscriber peer connections
            cleanupAllSubscribers();
            
            // Stop local stream
            if (state.localStream) {
                state.localStream.getTracks().forEach(track => track.stop());
                state.localStream = null;
            }
            
            // Remove video elements
            removeVideoElement('local-camera');
            removeVideoElement('local-screen');
            
            // Reset state (already cleaned by cleanup functions above)
            state.roomId = null;
            state.mainSessionId = null;
            state.cameraHandleId = null;
            state.screenHandleId = null;
            state.screenStream = null;
            state.subscriberPcs = {};
            state.subscriberHandles = {};
            state.publishers = [];
            state.micMuted = false;
            
            log('   State variables reset');
            
            // Reset UI
            document.getElementById('currentRoomId').textContent = '-';
            document.getElementById('mainSessionId').textContent = '-';
            document.getElementById('sessionStatus').textContent = 'Not joined';
            document.getElementById('sessionStatus').className = 'badge bg-secondary';
            document.getElementById('micBtn').textContent = 'üé§ Mute Mic';
            document.getElementById('micBtn').className = 'btn btn-secondary';
            document.getElementById('micStatus').textContent = 'ON';
            document.getElementById('micStatus').className = 'badge bg-success';
            
            log('‚úÖ State cleaned up');
        }
        
        /**
         * Leave room and cleanup everything
         */
        async function leaveRoom() {
            if (!state.roomId) {
                alert('You are not in any room');
                return;
            }
            
            try {
                log('üö™ Leaving room...');
                
                // Call backend to leave room
                const response = await fetch(`${API_BASE}/live/leave/${state.roomId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                
                if (response.ok) {
                    log('‚úÖ Left room successfully');
                } else {
                    const data = await response.json();
                    log(`‚ö†Ô∏è Leave room failed on backend: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`‚ùå Error leaving room: ${error.message}`);
            } finally {
                // Always cleanup state regardless of backend response
                cleanupState();
            }
        }
        
        // ===== Keepalive helpers - ONE timer for main session =====
        async function sendKeepalive(sessionId) {
            try {
                await fetch(`${API_BASE}/live/keepalive/${sessionId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                log(`üíì Keepalive sent for main session ${sessionId}`);
            } catch (e) {
                log(`‚ùå Keepalive error: ${e.message}`);
            }
        }

        function startKeepalive(sessionId) {
            stopKeepalive();
            if (!sessionId) return;
            state.keepaliveTimer = setInterval(() => sendKeepalive(sessionId), 30000);
            log(`‚è±Ô∏è Keepalive started for main session ${sessionId}`);
        }

        function stopKeepalive() {
            if (state.keepaliveTimer) {
                clearInterval(state.keepaliveTimer);
                state.keepaliveTimer = null;
                log(`üõë Keepalive stopped`);
            }
        }

        // ==================== RECORDING FUNCTIONS ====================
        
        /**
         * Start Recording - Merge screen + mic + system audio
         * ‚≠ê SIMPLIFIED VERSION: Uses timeslice for automatic chunking (30s)
         */
        async function startRecording() {
            if (!state.roomId) {
                alert('Please join room first');
                return;
            }
            
            const roomId = state.roomId;
            
            try {
                log('üé¨ Starting recording...');
                updateRecStatus('Initializing...', 'warning');
                
                // 1. Get screen stream with system audio
                log('üì∫ Requesting screen share with audio...');
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { 
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    },
                    audio: true // System audio
                });
                
                state.recording.screenStream = screenStream;
                
                // Handle when user stops sharing via browser button
                screenStream.getVideoTracks()[0].onended = () => {
                    log('‚ö†Ô∏è Screen sharing stopped by user');
                    stopRecording();
                };
                
                // 2. Get microphone stream
                log('üé§ Requesting microphone access...');
                const micStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                state.recording.micStream = micStream;
                
                // 3. Merge audio tracks using Web Audio API
                log('üéµ Merging audio tracks...');
                const audioContext = new AudioContext();
                state.recording.audioContext = audioContext;
                
                const destination = audioContext.createMediaStreamDestination();
                
                // Add screen audio if available
                const screenAudioTracks = screenStream.getAudioTracks();
                if (screenAudioTracks.length > 0) {
                    const screenAudioSource = audioContext.createMediaStreamSource(
                        new MediaStream(screenAudioTracks)
                    );
                    screenAudioSource.connect(destination);
                    log('‚úÖ System audio added');
                } else {
                    log('‚ö†Ô∏è No system audio in screen share');
                }
                
                // Add microphone audio
                const micAudioSource = audioContext.createMediaStreamSource(micStream);
                micAudioSource.connect(destination);
                log('‚úÖ Microphone added');
                
                // 4. Create combined stream: screen video + merged audio
                const combinedStream = new MediaStream([
                    ...screenStream.getVideoTracks(),
                    ...destination.stream.getAudioTracks()
                ]);
                
                state.recording.combinedStream = combinedStream;
                log(`‚úÖ Combined stream created: ${combinedStream.getTracks().length} tracks`);
                
                // 5. Setup MediaRecorder with WebM format
                // ‚≠ê USE VP8 instead of VP9 for better chunk stability
                // VP8 creates chunks with complete headers, VP9 metadata is distributed ‚Üí chunks after first may be corrupted
                const options = {
                    mimeType: 'video/webm;codecs=vp8,opus',
                    videoBitsPerSecond: 2500000, // 2.5 Mbps
                    audioBitsPerSecond: 128000  // 128 kbps for audio
                };
                
                // Verify codec support
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    throw new Error(`MediaRecorder does not support ${options.mimeType}`);
                }
                
                log('‚úÖ Using VP8 codec for stable chunk recording');
                
                // 6. Store options and stream for restart
                state.recording.recordingOptions = options;
                state.recording.recordingStream = combinedStream;
                
                // 7. Function to create and setup MediaRecorder
                function createMediaRecorder() {
                    // Use stored stream and options for restart capability
                    const stream = state.recording.recordingStream || combinedStream;
                    const opts = state.recording.recordingOptions || options;
                    const mr = new MediaRecorder(stream, opts);
                    
                    mr.ondataavailable = async (event) => {
                        if (!event.data || event.data.size < 1000) {
                            log(`‚ö†Ô∏è Chunk ${state.recording.chunkIndex} has no data or size is 0, skipping...`);
                            return;
                        }
                        
                        const blob = event.data;
                        const currentChunkIndex = state.recording.chunkIndex;
                        const duration = 30; // Each chunk is exactly 30s
                        
                        log(`üì¶ Chunk ${currentChunkIndex} ready (${(blob.size / 1024 / 1024).toFixed(2)} MB, ~30s)`);
                        
                        // Upload chunk immediately
                        try {
                            await uploadChunk(roomId, currentChunkIndex, blob, duration);
                            // CRITICAL: Only increment chunkIndex AFTER successful upload
                            state.recording.chunkIndex++;
                            state.recording.uploadedChunks++;
                            log(`‚úÖ Chunk ${currentChunkIndex} uploaded successfully (total: ${state.recording.uploadedChunks})`);
                        } catch (error) {
                            log(`‚ùå Failed to upload chunk ${currentChunkIndex}: ${error.message}`);
                            // Don't increment chunkIndex on failure
                            // Continue recording even if one chunk fails
                        }
                    };
                    
                    mr.onerror = (event) => {
                        log(`‚ùå MediaRecorder error: ${event.error}`);
                        updateRecStatus('Error', 'danger');
                    };
                    
                    mr.onstop = async () => {
                        log(`üõë MediaRecorder stopped (chunk ${state.recording.chunkIndex} complete)`);
                        
                        // CRITICAL: Check if we're stopping - don't restart if user clicked stop
                        if (state.recording.isStopping || !state.recording.isRecording) {
                            log('üõë Recording is stopping, NOT restarting MediaRecorder');
                            return; // Exit early - don't restart
                        }
                        
                        // Wait a bit for final data
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Double check: Restart recording ONLY if still active and NOT stopping
                        if (state.recording.isRecording && !state.recording.isStopping) {
                            log(`üîÑ Restarting MediaRecorder for next chunk...`);
                            
                            try {
                                // Create new MediaRecorder to ensure clean state
                                const newMediaRecorder = createMediaRecorder();
                                state.recording.mediaRecorder = newMediaRecorder;
                                newMediaRecorder.start(); // Start without timeslice - creates complete WebM file
                                
                                log(`‚úÖ MediaRecorder restarted for chunk ${state.recording.chunkIndex}`);
                            } catch (error) {
                                log(`‚ùå Failed to restart MediaRecorder: ${error.message}`);
                                stopRecording();
                            }
                        } else {
                            log('‚ö†Ô∏è Not restarting: isRecording=' + state.recording.isRecording + ', isStopping=' + state.recording.isStopping);
                        }
                    };
                    
                    return mr;
                }
                
                // 8. Create initial MediaRecorder
                const mediaRecorder = createMediaRecorder();
                state.recording.mediaRecorder = mediaRecorder;
                
                // 9. Start recording WITHOUT timeslice - creates complete WebM file
                mediaRecorder.start(); // No timeslice - creates complete WebM file
                log(`‚úÖ MediaRecorder started (will stop/restart every 30s for complete chunks)`);
                
                // 10. Set timer to stop/restart every 30 seconds
                state.recording.chunkTimer = setInterval(() => {
                    if (state.recording.isRecording && state.recording.mediaRecorder && !state.recording.isStopping) {
                        const mrState = state.recording.mediaRecorder.state;
                        if (mrState === 'recording') {
                            log(`‚è∞ 30s elapsed, stopping MediaRecorder to create complete chunk...`);
                            state.recording.mediaRecorder.stop(); // This will trigger onstop and restart
                        } else {
                            log(`‚ö†Ô∏è MediaRecorder state is ${mrState}, not stopping`);
                        }
                    }
                }, 30000); // 30 seconds
                
                // Initialize state
                state.recording.isRecording = true;
                state.recording.isStopping = false; // Flag to prevent restart on stop
                state.recording.startTime = Date.now();
                state.recording.chunkIndex = 0;
                state.recording.uploadedChunks = 0;
                state.recording.roomId = roomId;
                state.recording.isCompleting = false; // Reset flag
                
                // Update UI
                document.getElementById('startRecBtn').disabled = true;
                document.getElementById('stopRecBtn').disabled = false;
                updateRecStatus('Recording...', 'danger');
                
                // Start duration timer
                startDurationTimer();
                
                log('‚úÖ Recording started! MediaRecorder will stop/restart every 30s');
                log('üí° Each chunk is a complete WebM file with header - can play independently');
                log('üí° Keep this tab active for best recording quality');
                
            } catch (error) {
                log(`‚ùå Failed to start recording: ${error.message}`);
                updateRecStatus('Failed', 'danger');
                alert(`Failed to start recording: ${error.message}\n\nMake sure you:\n1. Allow screen sharing\n2. Allow microphone access\n3. Check "Share audio" in screen share dialog`);
                cleanupRecording();
            }
        }
        
        /**
         * Stop Recording
         * ‚≠ê SIMPLIFIED VERSION: Stop recorder ‚Üí wait for final chunk ‚Üí call complete API
         */
        async function stopRecording() {
            if (!state.recording.isRecording) {
                alert('Recording not started');
                return;
            }
            
            // Prevent duplicate calls
            if (state.recording.isCompleting) {
                log('‚ö†Ô∏è Already completing recording, ignoring duplicate call');
                return;
            }
            
            try {
                log('üõë Stopping recording...');
                updateRecStatus('Stopping...', 'warning');
                
                // Set flags
                state.recording.isStopping = true; // Prevent restart in onstop
                state.recording.isRecording = false;
                state.recording.isCompleting = true; // Prevent duplicate complete API calls
                
                // Stop chunk timer FIRST to prevent timer from triggering
                if (state.recording.chunkTimer) {
                    clearInterval(state.recording.chunkTimer);
                    state.recording.chunkTimer = null;
                    log('‚è∞ Chunk timer stopped');
                }
                
                // Wait a bit to ensure timer callback doesn't fire
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Stop MediaRecorder - will fire ondataavailable with final chunk
                if (state.recording.mediaRecorder && state.recording.mediaRecorder.state !== 'inactive') {
                    log('üì§ Stopping MediaRecorder (will trigger final chunk)...');
                    state.recording.mediaRecorder.stop();
                }
                
                // Wait for final chunk to be uploaded (ondataavailable will handle it)
                log('‚è≥ Waiting for final chunk to be uploaded...');
                await waitForFinalChunk();
                
                // Calculate total duration
                const totalDurationSeconds = Math.floor((Date.now() - state.recording.startTime) / 1000);
                state.recording.totalDurationSeconds = totalDurationSeconds;
                
                const roomId = state.recording.roomId || state.roomId;
                // CRITICAL: Use uploadedChunks (actual uploaded count) not chunkIndex
                const totalChunks = state.recording.uploadedChunks;
                
                if (!roomId) {
                    log(`‚ùå Cannot complete: roomId is empty`);
                    throw new Error('Room ID is required to complete recording');
                }
                
                if (totalChunks === 0) {
                    log(`‚ö†Ô∏è Warning: No chunks uploaded (${totalChunks}). Still calling complete API...`);
                }
                
                log(`üì§ Completing recording...`);
                log(`   Room ID: ${roomId}`);
                log(`   Total Chunks (uploaded): ${totalChunks}`);
                log(`   Chunk Index (next would be): ${state.recording.chunkIndex}`);
                log(`   Total Duration: ${totalDurationSeconds}s`);
                
                // Call complete API (only once)
                const response = await fetch(`${API_BASE}/live/recording/complete`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        roomId: parseInt(roomId),
                        totalChunks: totalChunks - 1, // Use actual uploaded count
                        totalDurationSeconds: totalDurationSeconds
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    log(`‚ùå Complete API failed: ${response.status} - ${errorText}`);
                    throw new Error(`Complete API failed: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                log(`‚úÖ Complete API response: ${JSON.stringify(data)}`);
                
                log('‚úÖ Recording completed! Backend is processing...');
                updateRecStatus('Processing...', 'info');
                document.getElementById('recordingResult').innerHTML = `
                    <div class="alert alert-success">
                        <strong>‚úÖ Recording Complete!</strong><br>
                        Total Duration: ${formatDuration(totalDurationSeconds)}<br>
                        Total Chunks: ${totalChunks}<br>
                        Status: ${data.status}<br>
                        <small class="text-muted">${data.message}</small>
                    </div>
                `;
                
                // Auto-check status after 5 seconds
                setTimeout(() => {
                    log('üîÑ Auto-checking recording status...');
                    checkRecordingStatus();
                }, 5000);
                
                // Cleanup
                cleanupRecording();
                
            } catch (error) {
                log(`‚ùå Error stopping recording: ${error.message}`);
                console.error('‚ùå Stop recording error:', error);
                updateRecStatus('Error', 'danger');
                
                // Don't call complete API again in catch block - already handled above
                // Just cleanup
                cleanupRecording();
            }
        }
        
        /**
         * Wait for final chunk to be uploaded
         * Simple delay to ensure ondataavailable has fired and uploaded the final chunk
         */
        function waitForFinalChunk() {
            return new Promise((resolve) => setTimeout(resolve, 1500));
        }
        
        /**
         * Upload a single chunk to backend
         */
        async function uploadChunk(roomId, chunkIndex, blob, durationSeconds) {
            try {
                // Validate blob before upload
                if (!blob || blob.size === 0) {
                    log(`‚ö†Ô∏è Chunk ${chunkIndex} is empty, skipping upload`);
                    return;
                }
                
                if (blob.size < 1000) {
                    log(`‚ö†Ô∏è Chunk ${chunkIndex} is too small (${blob.size} bytes), may be corrupt`);
                }
                
                log(`üì§ Uploading chunk ${chunkIndex} (${(blob.size / 1024 / 1024).toFixed(2)} MB)...`);
                document.getElementById('recordingProgress').style.display = 'block';
                document.getElementById('uploadProgress').style.width = '50%';
                
                // ‚≠ê CRITICAL: DO NOT wrap blob - it breaks WebM structure!
                // Wrapping blob destroys metadata/header layout ‚Üí chunks after first won't play
                // Use original blob directly from MediaRecorder
                const formData = new FormData();
                formData.append('file', blob, `chunk_${String(chunkIndex).padStart(3, '0')}.webm`);
                
                const url = `${API_BASE}/live/recording/upload-chunk?roomId=${roomId}&chunkIndex=${chunkIndex}&durationSeconds=${durationSeconds}`;
                
                // Upload with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60s timeout
                
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        },
                        body: formData,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        log(`‚úÖ Chunk ${chunkIndex} uploaded successfully (${data.totalChunksUploaded} total)`);
                        state.recording.uploadedChunks = data.totalChunksUploaded;
                        document.getElementById('recChunks').textContent = data.totalChunksUploaded;
                        document.getElementById('recLastUpload').textContent = new Date().toLocaleTimeString();
                        document.getElementById('uploadProgress').style.width = '100%';
                        
                        setTimeout(() => {
                            document.getElementById('recordingProgress').style.display = 'none';
                            document.getElementById('uploadProgress').style.width = '0%';
                        }, 1000);
                    } else {
                        log(`‚ùå Failed to upload chunk ${chunkIndex}: ${JSON.stringify(data)}`);
                        throw new Error(`Upload failed: ${data.message || 'Unknown error'}`);
                    }
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    if (fetchError.name === 'AbortError') {
                        throw new Error('Upload timeout after 60 seconds');
                    }
                    throw fetchError;
                }
                
            } catch (error) {
                log(`‚ùå Error uploading chunk ${chunkIndex}: ${error.message}`);
                // Don't throw - continue recording even if one chunk fails
                document.getElementById('recordingProgress').style.display = 'none';
                throw error; // Re-throw so caller knows it failed
            }
        }
        
        /**
         * Check recording status
         */
        async function checkRecordingStatus() {
            if (!state.roomId) {
                alert('Please join room first');
                return;
            }
            
            const roomId = state.roomId;
            
            try {
                log('üìä Checking recording status...');
                
                const response = await fetch(`${API_BASE}/live/recording/status/${roomId}`, {
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`‚úÖ Status: ${data.status} - ${data.message}`);
                    
                    updateRecStatus(data.status, getStatusBadgeClass(data.status));
                    
                    let resultHtml = `
                        <div class="alert alert-${getStatusAlertClass(data.status)}">
                            <strong>üìä Recording Status</strong><br>
                            Status: <span class="badge bg-${getStatusBadgeClass(data.status)}">${data.status}</span><br>
                            Message: ${data.message}<br>
                    `;
                    
                    if (data.totalChunks) {
                        resultHtml += `Total Chunks: ${data.totalChunks}<br>`;
                    }
                    if (data.durationSeconds) {
                        resultHtml += `Duration: ${formatDuration(data.durationSeconds)}<br>`;
                    }
                    if (data.videoUrl) {
                        resultHtml += `
                            <hr>
                            <strong>üé• Recording Ready!</strong><br>
                            <a href="${data.videoUrl}" target="_blank" class="btn btn-success mt-2">
                                üì• Download Video
                            </a>
                            <button onclick="openVideoInNewTab('${data.videoUrl}')" class="btn btn-primary mt-2">
                                ‚ñ∂Ô∏è Play Video
                            </button>
                        `;
                    }
                    
                    resultHtml += '</div>';
                    document.getElementById('recordingResult').innerHTML = resultHtml;
                    
                } else {
                    log(`‚ùå Failed to get status: ${JSON.stringify(data)}`);
                }
                
            } catch (error) {
                log(`‚ùå Error checking status: ${error.message}`);
            }
        }
        
        /**
         * Open video in new tab
         */
        function openVideoInNewTab(url) {
            window.open(url, '_blank');
        }
        
        /**
         * Cleanup recording resources
         */
        function cleanupRecording() {
            // Stop all tracks
            if (state.recording.screenStream) {
                state.recording.screenStream.getTracks().forEach(track => track.stop());
            }
            if (state.recording.micStream) {
                state.recording.micStream.getTracks().forEach(track => track.stop());
            }
            if (state.recording.combinedStream) {
                state.recording.combinedStream.getTracks().forEach(track => track.stop());
            }
            
            // Close audio context
            if (state.recording.audioContext) {
                state.recording.audioContext.close();
            }
            
            // Stop duration timer
            if (state.recording.durationTimer) {
                clearInterval(state.recording.durationTimer);
            }
            
            // Stop chunk timer
            if (state.recording.chunkTimer) {
                clearInterval(state.recording.chunkTimer);
            }
            
            // Reset state
            state.recording = {
                mediaRecorder: null,
                combinedStream: null,
                chunkIndex: 0,
                isRecording: false,
                isStopping: false,
                startTime: null,
                durationTimer: null,
                chunkTimer: null,
                totalDurationSeconds: 0,
                uploadedChunks: 0,
                screenStream: null,
                micStream: null,
                audioContext: null,
                roomId: null,
                isCompleting: false,
                recordingOptions: null,
                recordingStream: null
            };
            
            // Reset UI
            document.getElementById('startRecBtn').disabled = false;
            document.getElementById('stopRecBtn').disabled = true;
            document.getElementById('recDuration').textContent = '00:00';
            document.getElementById('recChunks').textContent = '0';
        }
        
        /**
         * Start duration timer
         */
        function startDurationTimer() {
            state.recording.durationTimer = setInterval(() => {
                if (state.recording.startTime) {
                    const seconds = Math.floor((Date.now() - state.recording.startTime) / 1000);
                    document.getElementById('recDuration').textContent = formatDuration(seconds);
                }
            }, 1000);
        }
        
        /**
         * Format duration (seconds to MM:SS)
         */
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        /**
         * Update recording status badge
         */
        function updateRecStatus(status, badgeClass) {
            const badge = document.getElementById('recStatus');
            badge.textContent = status;
            badge.className = `badge bg-${badgeClass}`;
        }
        
        /**
         * Get badge class for status
         */
        function getStatusBadgeClass(status) {
            switch (status) {
                case 'NOT_STARTED': return 'secondary';
                case 'RECORDING': return 'danger';
                case 'PROCESSING': return 'info';
                case 'COMPLETED': return 'success';
                case 'FAILED': return 'danger';
                default: return 'secondary';
            }
        }
        
        /**
         * Get alert class for status
         */
        function getStatusAlertClass(status) {
            switch (status) {
                case 'COMPLETED': return 'success';
                case 'PROCESSING': return 'info';
                case 'RECORDING': return 'warning';
                case 'FAILED': return 'danger';
                default: return 'info';
            }
        }
        
        // ==================== END RECORDING FUNCTIONS ====================

        // Initial log
        log('üöÄ Live Streaming Test Page Loaded');
        log('üìù Enter your access token and click "Save Tokens" to begin');
        log('');
        log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        log('üîß WEBRTC IMPLEMENTATION (based on janus.js patterns)');
        log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        log('üìö Reference: https://janus.conf.meetecho.com/docs/videoroom');
        log('');
        log('üì° SDP Offer/Answer Flow:');
        log('   Publisher: createOffer() ‚Üí waitForIceGathering() ‚Üí send to Janus ‚Üí receive answer');
        log('   Subscriber: receive offer from Janus ‚Üí createAnswer() ‚Üí waitForIceGathering() ‚Üí send');
        log('');
        log('üßä ICE Handling (non-trickle mode):');
        log('   - Wait for all ICE candidates before sending SDP');
        log('   - Detect end via null candidate or iceGatheringState=complete');
        log('   - Timeout after 10s if gathering is slow');
        log('');
        log('üí° ARCHITECTURE: 1 Session - Multiple Handles');
        log('   1Ô∏è‚É£ Join room ‚Üí Creates main session');
        log('   2Ô∏è‚É£ Publish camera/screen ‚Üí Creates handles on same session');
        log('   3Ô∏è‚É£ Unpublish ‚Üí Destroys handle (keeps session)');
        log('   4Ô∏è‚É£ Leave room ‚Üí Destroys session & all handles');
        log('');
        log('üé¨ Recording: Stop/restart every 30s - Each chunk is complete WebM');
        log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        log('');
    </script>
</body>
</html>


