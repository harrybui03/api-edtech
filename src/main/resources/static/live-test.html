<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Streaming Test</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .video-box {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        .video-box video {
            width: 100%;
            height: auto;
            display: block;
        }
        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .controls {
            margin-top: 10px;
        }
        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }
        .btn-group-sm .btn {
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <h1 class="mb-4">ğŸ¥ Live Streaming Test</h1>
        
        <!-- Login Section -->
        <div class="section" id="login-section">
            <h3>ğŸ” Authentication</h3>
            <div class="row g-3">
                <div class="col-md-5">
                    <label class="form-label">Access Token:</label>
                    <input type="text" id="accessToken" class="form-control" placeholder="Paste your access token">
                </div>
                <div class="col-md-5">
                    <label class="form-label">Refresh Token (optional):</label>
                    <input type="text" id="refreshToken" class="form-control" placeholder="Paste your refresh token">
                </div>
                <div class="col-md-2 d-flex align-items-end">
                    <button onclick="saveTokens()" class="btn btn-primary w-100">Save Tokens</button>
                </div>
            </div>
            <div class="mt-2">
                <small class="text-muted">Status: <span id="auth-status" class="badge bg-secondary">Not authenticated</span></small>
            </div>
        </div>

        <!-- Instructor Controls -->
        <div class="section">
            <h3>ğŸ‘¨â€ğŸ« Instructor Controls</h3>
            <div class="row g-3">
                <div class="col-md-4">
                    <label class="form-label">Batch ID:</label>
                    <input type="text" id="batchId" class="form-control" placeholder="Enter batch UUID">
                </div>
                <div class="col-md-3">
                    <label class="form-label">Title:</label>
                    <input type="text" id="liveTitle" class="form-control" value="Live Session Test">
                </div>
                <div class="col-md-5">
                    <label class="form-label">Description:</label>
                    <input type="text" id="liveDescription" class="form-control" value="Testing live streaming">
                </div>
            </div>
            <div class="controls">
                <button onclick="startLive()" class="btn btn-success">Start Live</button>
                <button onclick="endLive()" class="btn btn-danger">End Live</button>
            </div>
            <div class="mt-2">
                <small>Room ID: <strong id="roomId">-</strong></small>
            </div>
        </div>

        <!-- Join & Publish Section -->
        <div class="section">
            <h3>ğŸ“¹ Join Room & Publish Streams</h3>
            <div class="row g-3">
                <div class="col-md-6">
                    <label class="form-label">Room ID:</label>
                    <input type="text" id="joinRoomId" class="form-control" placeholder="Enter room ID">
                </div>
                <div class="col-md-6">
                    <label class="form-label">Your Name (optional):</label>
                    <input type="text" id="displayName" class="form-control" placeholder="Enter your name">
                </div>
            </div>
            
            <!-- Join Room Button -->
            <div class="controls mt-3">
                <button onclick="joinRoom()" class="btn btn-primary btn-lg">ğŸšª Join Room</button>
                <small class="ms-2">Session: <span id="sessionStatus" class="badge bg-secondary">Not joined</span></small>
            </div>
            
            <!-- Publish Buttons -->
            <div class="controls mt-3">
                <button onclick="publishCamera()" class="btn btn-success">ğŸ“¹ Publish Camera</button>
                <button onclick="publishScreen()" class="btn btn-info">ğŸ–¥ï¸ Publish Screen</button>
                <button onclick="toggleMic()" id="micBtn" class="btn btn-secondary">ğŸ¤ Mute Mic</button>
                <button onclick="unpublishCamera()" class="btn btn-warning" id="stopCameraBtn">â¹ï¸ Stop Camera</button>
                <button onclick="unpublishScreen()" class="btn btn-warning">â¹ï¸ Stop Screen</button>
            </div>
            
            <div class="mt-2">
                <small>Room: <strong id="currentRoomId">-</strong></small> | 
                <small>Session: <strong id="mainSessionId">-</strong></small> | 
                <small>Mic: <span id="micStatus" class="badge bg-success">ON</span></small>
            </div>
            <p class="text-muted mt-2 mb-0">
                <small>ğŸ’¡ <strong>Best practice:</strong> Join room first â†’ Then publish camera/screen</small><br>
                <small>ğŸ”¥ All operations (join, publish, subscribe) use the same session!</small>
            </p>
        </div>

        <!-- Watch Others -->
        <div class="section">
            <h3>ğŸ‘€ Watch Others</h3>
            <div class="controls">
                <button onclick="listParticipants()" class="btn btn-primary">List Participants</button>
                <button onclick="subscribeToAll()" class="btn btn-success">Subscribe to All</button>
            </div>
            <div id="participantsList" class="mt-3"></div>
        </div>

        <!-- Video Display -->
        <div class="section">
            <h3>ğŸ“º Video Streams</h3>
            <div class="video-container" id="videoContainer">
                <!-- Videos will be added here dynamically -->
            </div>
        </div>

        <!-- Logs -->
        <div class="section">
            <h3>ğŸ“‹ Logs</h3>
            <div class="log-container" id="logContainer"></div>
            <button onclick="clearLogs()" class="btn btn-sm btn-secondary mt-2">Clear Logs</button>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000/api/v1';
        let accessToken = '';
        let refreshToken = '';
        
        // State management - NEW ARCHITECTURE: 1 Session - Multiple Handles
        let state = {
            roomId: null,
            mainSessionId: null,  // ğŸ”¥ ONE main session for all (join, publish, subscribe)
            // Peer connections
            cameraPc: null,
            cameraHandleId: null,
            screenPc: null,
            screenHandleId: null,
            subscriberPcs: {},
            subscriberHandles: {},  // Track subscriber handles
            publishers: [],
            keepaliveTimer: null,  // ğŸ”¥ ONE keepalive timer for main session
            micMuted: false,
            localStream: null
        };

        // ===== Authentication =====
        function saveTokens() {
            accessToken = document.getElementById('accessToken').value.trim();
            refreshToken = document.getElementById('refreshToken').value.trim();
            
            if (accessToken) {
                document.getElementById('auth-status').textContent = 'Authenticated';
                document.getElementById('auth-status').className = 'badge bg-success';
                log('âœ… Tokens saved successfully');
            } else {
                document.getElementById('auth-status').textContent = 'Not authenticated';
                document.getElementById('auth-status').className = 'badge bg-danger';
                log('âŒ Please enter access token');
            }
        }

        function getHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            };
        }

        // ===== Logging =====
        function log(message) {
            const logContainer = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            logContainer.innerHTML += `[${time}] ${message}\n`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('logContainer').innerHTML = '';
        }

        // ===== Video Management =====
        function addVideoElement(streamId, stream, label) {
            const container = document.getElementById('videoContainer');
            
            // Remove existing video if any
            const existing = document.getElementById(streamId);
            if (existing) {
                existing.remove();
            }
            
            const videoBox = document.createElement('div');
            videoBox.className = 'video-box';
            videoBox.id = streamId;
            
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsinline = true;
            video.muted = label.includes('Local'); // Mute local videos
            video.srcObject = stream;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'video-label';
            labelDiv.textContent = label;
            
            videoBox.appendChild(video);
            videoBox.appendChild(labelDiv);
            container.appendChild(videoBox);
            
            log(`ğŸ“¹ Added video: ${label}`);
        }

        function removeVideoElement(streamId) {
            const element = document.getElementById(streamId);
            if (element) {
                element.remove();
                log(`ğŸ—‘ï¸ Removed video: ${streamId}`);
            }
        }

        // ===== Start Live (Instructor) =====
        async function startLive() {
            const batchId = document.getElementById('batchId').value.trim();
            const title = document.getElementById('liveTitle').value.trim();
            const description = document.getElementById('liveDescription').value.trim();
            
            if (!batchId) {
                alert('Please enter batch ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/start`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ batchId, title, description })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    state.roomId = data.roomId;
                    document.getElementById('roomId').textContent = data.roomId;
                    document.getElementById('joinRoomId').value = data.roomId;
                    log(`âœ… Live started! Room ID: ${data.roomId}`);
                } else {
                    log(`âŒ Start live failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== End Live =====
        async function endLive() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/end/${roomId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`âœ… Live ended successfully`);
                } else {
                    log(`âŒ End live failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Join Room =====
        async function joinRoom() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            const displayName = document.getElementById('displayName').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const requestBody = { 
                    roomId: parseInt(roomId), 
                    ptype: 'publisher',  // Always join as publisher
                    displayName: displayName || undefined
                };
                
                const response = await fetch(`${API_BASE}/live/join`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // ğŸ”¥ Save main session ID - will be reused for ALL operations
                    state.mainSessionId = data.sessionId;
                    state.roomId = parseInt(roomId);
                    
                    // Update UI
                    document.getElementById('currentRoomId').textContent = roomId;
                    document.getElementById('mainSessionId').textContent = state.mainSessionId;
                    document.getElementById('sessionStatus').textContent = 'Joined âœ…';
                    document.getElementById('sessionStatus').className = 'badge bg-success';
                    
                    // Start keepalive for main session
                    startKeepalive(state.mainSessionId);
                    
                    const name = displayName || 'Anonymous';
                    log(`âœ… Joined room ${roomId} as publisher (${name})`);
                    log(`ğŸ”¥ Main session created: ${state.mainSessionId}`);
                    log(`ğŸ’¡ This session will be reused for camera, screen, and subscribe!`);
                } else {
                    log(`âŒ Join failed: ${JSON.stringify(data)}`);
                    document.getElementById('sessionStatus').textContent = 'Failed âŒ';
                    document.getElementById('sessionStatus').className = 'badge bg-danger';
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Publish Camera =====
        async function publishCamera() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                // Get camera stream
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                state.localStream = stream; // Save stream for mic control
                addVideoElement('local-camera', stream, 'Local Camera');
                
                // Create peer connection with ICE servers
                const pcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                state.cameraPc = new RTCPeerConnection(pcConfig);
                stream.getTracks().forEach(track => state.cameraPc.addTrack(track, stream));
                
                // Create offer
                const offer = await state.cameraPc.createOffer();
                await state.cameraPc.setLocalDescription(offer);
                
                // Wait for ICE gathering to complete
                if (state.cameraPc.iceGatheringState !== 'complete') {
                    log(`â³ Waiting for ICE gathering... (current state: ${state.cameraPc.iceGatheringState})`);
                    
                    // Log ICE candidates as they come in
                    state.cameraPc.onicecandidate = (event) => {
                        if (event.candidate) {
                            log(`ğŸ” ICE candidate: ${event.candidate.type} - ${event.candidate.address || event.candidate.candidate}`);
                        } else {
                            log('ğŸ” ICE gathering finished (null candidate)');
                        }
                    };
                    
                    await new Promise((resolve) => {
                        const checkState = () => {
                            if (state.cameraPc.iceGatheringState === 'complete') {
                                log(`âœ… ICE gathering complete (${state.cameraPc.iceGatheringState})`);
                                resolve();
                            }
                        };
                        state.cameraPc.addEventListener('icegatheringstatechange', checkState);
                        // Timeout after 5 seconds
                        setTimeout(() => {
                            state.cameraPc.removeEventListener('icegatheringstatechange', checkState);
                            log(`âš ï¸ ICE gathering timeout (state: ${state.cameraPc.iceGatheringState}), proceeding anyway`);
                            resolve();
                        }, 5000);
                    });
                } else {
                    log('âœ… ICE already complete');
                }
                
                // Use updated SDP with ICE candidates
                const finalOffer = state.cameraPc.localDescription;
                
                log('ğŸ“¤ Publishing camera stream...');
                log(`SDP Offer (first 200 chars): ${finalOffer.sdp.substring(0, 200)}...`);
                
                // Validate SDP doesn't have 0.0.0.0 (indicates no ICE candidates)
                if (finalOffer.sdp.includes('c=IN IP4 0.0.0.0')) {
                    log('âš ï¸ WARNING: SDP contains c=IN IP4 0.0.0.0 - ICE gathering may have failed!');
                    log('âš ï¸ This will cause Janus to reject the offer with error 490');
                    
                    // Try to proceed anyway, but warn user
                    const proceed = confirm('SDP has no valid ICE candidates (0.0.0.0). Try anyway?');
                    if (!proceed) {
                        log('âŒ Publish cancelled by user');
                        return;
                    }
                }
                
                // Check for valid ICE candidates in SDP
                const hasCandidates = finalOffer.sdp.includes('a=candidate:');
                log(`ğŸ“Š SDP has ICE candidates: ${hasCandidates}`);
                
                // ğŸ”¥ Send to backend (backend auto-detects sessionId/handleId from DB!)
                const publishPayload = { 
                    roomId: parseInt(roomId), 
                    sdp: finalOffer.sdp,  // Use final SDP with ICE candidates
                    streamType: 'camera'
                };
                
                log('âœ… Sending publish request (backend creates new session automatically)');
                
                // Update current room ID display
                document.getElementById('currentRoomId').textContent = roomId;
                
                const response = await fetch(`${API_BASE}/live/publish`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify(publishPayload)
                });
                
                const data = await response.json();
                
                if (response.ok && data.sdpAnswer) {
                    log('ğŸ“¥ Received SDP answer from server');
                    log(`SDP Answer (first 200 chars): ${data.sdpAnswer.substring(0, 200)}...`);
                    
                    // ğŸ”¥ Save camera handle (session is main session, already tracked)
                    if (data.sessionId && data.handleId) {
                        // Verify sessionId matches main session
                        if (state.mainSessionId && data.sessionId !== state.mainSessionId) {
                            log(`âš ï¸ Warning: Camera session ${data.sessionId} differs from main ${state.mainSessionId}`);
                        }
                        state.mainSessionId = data.sessionId;  // Ensure we have it
                        state.cameraHandleId = data.handleId;
                        log(`âœ… Camera published: session ${state.mainSessionId}, handle: ${state.cameraHandleId}`);
                    } else {
                        log('âš ï¸ Backend did not return sessionId/handleId in response');
                    }
                    
                    // Check if SDP contains ICE candidates
                    if (data.sdpAnswer.includes('c=IN IP4 0.0.0.0')) {
                        log('âš ï¸ WARNING: SDP answer contains 0.0.0.0 - may have ICE issues');
                    }
                    
                    // Check peer connection state before setting remote description
                    log(`ğŸ“Š PeerConnection state before setRemoteDescription: ${state.cameraPc.signalingState}`);
                    
                    if (state.cameraPc.signalingState !== 'have-local-offer') {
                        log(`âŒ Invalid signaling state: ${state.cameraPc.signalingState}. Expected: have-local-offer`);
                        throw new Error(`Cannot set remote answer in state: ${state.cameraPc.signalingState}`);
                    }
                    
                    try {
                        await state.cameraPc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: data.sdpAnswer
                        }));
                        log('âœ… Remote description set successfully');
                        log(`ğŸ“Š PeerConnection state after: ${state.cameraPc.signalingState}`);
                        log('âœ… Camera published successfully');
                    } catch (setRemoteError) {
                        log(`âŒ Error setting remote description: ${setRemoteError.message}`);
                        log(`SDP Answer that caused error: ${data.sdpAnswer}`);
                        throw setRemoteError;
                    }
                } else if (data.error) {
                    log(`âŒ Publish failed - Server error: ${data.error} (code: ${data.errorCode})`);
                    if (data.errorCode === 490) {
                        log('ğŸ’¡ ICE error 490 - This usually means:');
                        log('   1. SDP offer has invalid ICE candidates');
                        log('   2. SDP contains c=IN IP4 0.0.0.0');
                        log('   3. STUN servers are not working');
                        log('   Check your SDP offer above for 0.0.0.0 addresses');
                    }
                } else {
                    log(`âŒ Publish failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Publish Screen =====
        async function publishScreen() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                // Get screen stream
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                addVideoElement('local-screen', stream, 'Local Screen');
                
                // Handle when user stops sharing
                stream.getVideoTracks()[0].onended = () => {
                    log('âš ï¸ Screen sharing stopped by user');
                    unpublishScreen();
                };
                
                // Create peer connection with ICE servers
                const pcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                state.screenPc = new RTCPeerConnection(pcConfig);
                stream.getTracks().forEach(track => state.screenPc.addTrack(track, stream));
                
                // Create offer
                const offer = await state.screenPc.createOffer();
                await state.screenPc.setLocalDescription(offer);
                
                // Wait for ICE gathering to complete
                if (state.screenPc.iceGatheringState !== 'complete') {
                    log(`â³ Waiting for ICE gathering... (current state: ${state.screenPc.iceGatheringState})`);
                    
                    // Log ICE candidates as they come in
                    state.screenPc.onicecandidate = (event) => {
                        if (event.candidate) {
                            log(`ğŸ” ICE candidate: ${event.candidate.type} - ${event.candidate.address || event.candidate.candidate}`);
                        } else {
                            log('ğŸ” ICE gathering finished (null candidate)');
                        }
                    };
                    
                    await new Promise((resolve) => {
                        const checkState = () => {
                            if (state.screenPc.iceGatheringState === 'complete') {
                                log(`âœ… ICE gathering complete (${state.screenPc.iceGatheringState})`);
                                resolve();
                            }
                        };
                        state.screenPc.addEventListener('icegatheringstatechange', checkState);
                        // Timeout after 5 seconds
                        setTimeout(() => {
                            state.screenPc.removeEventListener('icegatheringstatechange', checkState);
                            log(`âš ï¸ ICE gathering timeout (state: ${state.screenPc.iceGatheringState}), proceeding anyway`);
                            resolve();
                        }, 5000);
                    });
                } else {
                    log('âœ… ICE already complete');
                }
                
                // Use updated SDP with ICE candidates
                const finalOffer = state.screenPc.localDescription;
                
                log('ğŸ“¤ Publishing screen share...');
                log(`SDP Offer (first 200 chars): ${finalOffer.sdp.substring(0, 200)}...`);
                
                // Send to backend
                const response = await fetch(`${API_BASE}/live/publish-screen`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ roomId: parseInt(roomId), sdp: finalOffer.sdp })
                });
                
                const data = await response.json();
                
                if (response.ok && data.sdpAnswer) {
                    // ğŸ”¥ Save screen handle (session is main session, already tracked)
                    if (data.sessionId && data.handleId) {
                        // Verify sessionId matches main session
                        if (state.mainSessionId && data.sessionId !== state.mainSessionId) {
                            log(`âš ï¸ Warning: Screen session ${data.sessionId} differs from main ${state.mainSessionId}`);
                        }
                        state.mainSessionId = data.sessionId;  // Ensure we have it
                        state.screenHandleId = data.handleId;
                    }
                    
                    await state.screenPc.setRemoteDescription(new RTCSessionDescription({
                        type: 'answer',
                        sdp: data.sdpAnswer
                    }));
                    log(`âœ… Screen published successfully. Session: ${state.mainSessionId}, Handle: ${state.screenHandleId}`);
                } else {
                    log(`âŒ Publish screen failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Unpublish Camera =====
        async function unpublishCamera() {
            console.log('ğŸ”´ unpublishCamera() called!'); // Debug
            log('ğŸ”´ unpublishCamera button clicked');
            
            const roomId = document.getElementById('joinRoomId').value.trim();
            log(`ğŸ” Room ID from input: "${roomId}"`);
            
            if (!roomId) {
                const msg = 'Please enter room ID';
                alert(msg);
                log(`âŒ Validation failed: ${msg}`);
                return;
            }
            
            try {
                log('ğŸ›‘ Stopping camera...');
                
                // Step 1: Stop ALL local stream tracks FIRST (this turns off camera LED)
                if (state.localStream) {
                    log('   Stopping local stream tracks...');
                    state.localStream.getTracks().forEach(track => {
                        log(`   - Stopping ${track.kind} track (id: ${track.id})`);
                        track.stop();
                    });
                    state.localStream = null;
                }
                
                // Step 2: Stop tracks from peer connection senders
                if (state.cameraPc) {
                    log('   Stopping peer connection senders...');
                    state.cameraPc.getSenders().forEach(sender => {
                        if (sender.track) {
                            log(`   - Stopping sender ${sender.track.kind} track`);
                            sender.track.stop();
                        }
                    });
                    
                    // Step 3: Close peer connection
                    log('   Closing peer connection...');
                    state.cameraPc.close();
                    state.cameraPc = null;
                }
                
                // Step 4: Remove video element
                removeVideoElement('local-camera');
                
                // Step 5: Reset mic state
                state.micMuted = false;
                document.getElementById('micBtn').textContent = 'ğŸ¤ Mute Mic';
                document.getElementById('micBtn').className = 'btn btn-secondary';
                document.getElementById('micStatus').textContent = 'ON';
                document.getElementById('micStatus').className = 'badge bg-success';
                
                // Step 6: Notify backend (backend will destroy handle, keep session)
                log('   Notifying backend...');
                const response = await fetch(`${API_BASE}/live/unpublish/${roomId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                
                if (response.ok) {
                    log('âœ… Camera unpublished and stopped completely');
                    // Clear handle state (keep main session!)
                    state.cameraHandleId = null;
                } else {
                    const data = await response.json();
                    log(`âŒ Unpublish camera failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error in unpublishCamera: ${error.message}`);
                console.error('âŒ Unpublish error:', error);
                alert(`Error stopping camera: ${error.message}`);
            }
            
            console.log('ğŸ”´ unpublishCamera() finished');
        }

        // ===== Unpublish Screen =====
        async function unpublishScreen() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                log('ğŸ›‘ Stopping screen share...');
                
                // Stop all screen tracks
                if (state.screenPc) {
                    log('   Stopping screen peer connection...');
                    state.screenPc.getSenders().forEach(sender => {
                        if (sender.track) {
                            sender.track.stop();
                        }
                    });
                    state.screenPc.close();
                    state.screenPc = null;
                }
                
                // Remove video element
                removeVideoElement('local-screen');
                
                // Backend auto-detects screen session/handle from DB
                log('   Notifying backend...');
                const response = await fetch(`${API_BASE}/live/unpublish-screen/${roomId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                
                if (response.ok) {
                    log('âœ… Screen share unpublished and stopped completely');
                    // Clear handle state (keep main session!)
                    state.screenHandleId = null;
                } else {
                    const data = await response.json();
                    log(`âŒ Unpublish screen failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error in unpublishScreen: ${error.message}`);
                console.error('Unpublish screen error:', error);
            }
        }

        // ===== Toggle Microphone =====
        function toggleMic() {
            if (!state.localStream) {
                alert('Please publish camera first');
                log('âš ï¸ No local stream available. Publish camera first.');
                return;
            }
            
            const audioTracks = state.localStream.getAudioTracks();
            if (audioTracks.length === 0) {
                alert('No audio track found');
                log('âš ï¸ No audio track in local stream');
                return;
            }
            
            state.micMuted = !state.micMuted;
            audioTracks.forEach(track => {
                track.enabled = !state.micMuted;
            });
            
            // Update UI
            const micBtn = document.getElementById('micBtn');
            const micStatus = document.getElementById('micStatus');
            
            if (state.micMuted) {
                micBtn.textContent = 'ğŸ¤ Unmute Mic';
                micBtn.className = 'btn btn-danger';
                micStatus.textContent = 'OFF';
                micStatus.className = 'badge bg-danger';
                log('ğŸ”‡ Microphone muted');
            } else {
                micBtn.textContent = 'ğŸ¤ Mute Mic';
                micBtn.className = 'btn btn-secondary';
                micStatus.textContent = 'ON';
                micStatus.className = 'badge bg-success';
                log('ğŸ”Š Microphone unmuted');
            }
        }

        // ===== List Participants =====
        async function listParticipants() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                // Backend automatically filters out all YOUR feeds (camera + screen)
                // No need to manually exclude - it uses your auth token to identify you!
                const url = `${API_BASE}/live/participants/${roomId}`;
                
                const response = await fetch(url, {
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    state.publishers = data.participants.filter(p => p.publisher);
                    
                    const container = document.getElementById('participantsList');
                    container.innerHTML = '<h5>ğŸŒ Active Streams (Others):</h5>';
                    
                    if (state.publishers.length === 0) {
                        container.innerHTML += '<p class="text-muted">No one else is streaming</p>';
                    }
                    
                    state.publishers.forEach(p => {
                        // Identify feed type by display name
                        const isScreen = p.display && p.display.includes('(Screen)');
                        const icon = isScreen ? 'ğŸ–¥ï¸' : 'ğŸ“¹';
                        
                        container.innerHTML += `
                            <div class="alert alert-info">
                                ${icon} <strong>${p.display}</strong> (Feed ID: ${p.id})
                                <button onclick="subscribeToPublisher(${p.id}, '${p.display}')" class="btn btn-sm btn-primary float-end">Watch</button>
                            </div>
                        `;
                    });
                    
                    log(`âœ… Found ${state.publishers.length} active stream(s) from others (your feeds auto-excluded)`);
                } else {
                    log(`âŒ List participants failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }
        
        // ===== Get My Feeds (Optional - for debugging) =====
        async function getMyFeeds() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/my-feeds/${roomId}`, {
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`ğŸ“Š My Feeds: ${JSON.stringify(data.feeds, null, 2)}`);
                    
                    if (data.feeds && data.feeds.length > 0) {
                        log(`âœ… You have ${data.feeds.length} active feed(s):`);
                        data.feeds.forEach(feed => {
                            log(`   - ${feed.feedType}: Feed ID ${feed.feedId} (${feed.displayName})`);
                        });
                    } else {
                        log(`â„¹ï¸ You have no active feeds in this room`);
                    }
                } else {
                    log(`âŒ Get my feeds failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Subscribe to Publisher =====
        async function subscribeToPublisher(feedId, displayName) {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                log(`Subscribing to ${displayName} (feed ${feedId})...`);
                
                // Step 1: Subscribe (backend will create new session/handle for this feed)
                const subscribeResponse = await fetch(`${API_BASE}/live/subscribe`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        roomId: parseInt(roomId),
                        feedId: feedId
                        // Note: No need to send sessionId/handleId, backend creates new ones
                    })
                });
                
                const subscribeData = await subscribeResponse.json();
                
                if (!subscribeResponse.ok || !subscribeData.sdpOffer) {
                    log(`Subscribe failed: ${JSON.stringify(subscribeData)}`);
                    return;
                }
                
                log(`Received SDP offer, new session: ${subscribeData.sessionId}, handle: ${subscribeData.handleId}`);
                
                // Step 2: Create peer connection with ICE servers
                const pcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                const pc = new RTCPeerConnection(pcConfig);
                state.subscriberPcs[feedId] = pc;
                
                // Handle incoming stream
                pc.ontrack = (event) => {
                    log(`ğŸ¬ ontrack event! Track kind: ${event.track.kind}, streams: ${event.streams.length}`);
                    const [stream] = event.streams;
                    if (stream) {
                        log(`ğŸ“º Stream ID: ${stream.id}, tracks: ${stream.getTracks().length}`);
                        addVideoElement(`remote-${feedId}`, stream, `Remote: ${displayName}`);
                    } else {
                        log('âš ï¸ No stream in ontrack event!');
                    }
                };
                
                // Monitor ICE connection state
                pc.oniceconnectionstatechange = () => {
                    log(`ğŸ”Œ ICE connection state: ${pc.iceConnectionState}`);
                };
                
                pc.onconnectionstatechange = () => {
                    log(`ğŸ”— Connection state: ${pc.connectionState}`);
                };
                
                // Set remote description (SDP offer from Janus)
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: subscribeData.sdpOffer
                }));
                
                // Create answer
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                // Wait for ICE gathering to complete (like publisher)
                if (pc.iceGatheringState !== 'complete') {
                    log(`â³ Waiting for subscriber ICE gathering... (state: ${pc.iceGatheringState})`);
                    
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            log(`ğŸ” Subscriber ICE candidate: ${event.candidate.type}`);
                        } else {
                            log('ğŸ” Subscriber ICE gathering finished');
                        }
                    };
                    
                    await new Promise((resolve) => {
                        const checkState = () => {
                            if (pc.iceGatheringState === 'complete') {
                                log(`âœ… Subscriber ICE gathering complete`);
                                resolve();
                            }
                        };
                        pc.addEventListener('icegatheringstatechange', checkState);
                        setTimeout(() => {
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            log(`âš ï¸ Subscriber ICE timeout (state: ${pc.iceGatheringState}), proceeding`);
                            resolve();
                        }, 5000);
                    });
                } else {
                    log('âœ… Subscriber ICE already complete');
                }
                
                // Use final SDP with ICE candidates
                const finalAnswer = pc.localDescription;
                
                // Step 3: Start subscriber (send SDP answer)
                // Use the NEW sessionId and handleId returned from subscribe
                const startResponse = await fetch(`${API_BASE}/live/start-subscriber`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        sessionId: subscribeData.sessionId,  // Use new session
                        handleId: subscribeData.handleId,    // Use new handle
                        sdpAnswer: finalAnswer.sdp           // Use final SDP with ICE
                    })
                });
                
                if (startResponse.ok) {
                    log(`âœ… Subscribed to ${displayName} successfully`);
                    
                    // ğŸ”¥ Verify subscriber reuses main session
                    if (state.mainSessionId && subscribeData.sessionId !== state.mainSessionId) {
                        log(`âš ï¸ Warning: Subscriber session ${subscribeData.sessionId} differs from main ${state.mainSessionId}`);
                    }
                    state.mainSessionId = subscribeData.sessionId;  // Ensure we have it
                    
                    // Store handle for this feed
                    state.subscriberHandles[feedId] = subscribeData.handleId;
                } else {
                    log(`âŒ Start subscriber failed`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Subscribe to All Publishers =====
        async function subscribeToAll() {
            if (state.publishers.length === 0) {
                alert('Please list participants first');
                return;
            }
            
            for (const publisher of state.publishers) {
                await subscribeToPublisher(publisher.id, publisher.display);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Delay between subscriptions
            }
        }

        // ===== Keepalive helpers - ONE timer for main session =====
        async function sendKeepalive(sessionId) {
            try {
                await fetch(`${API_BASE}/live/keepalive/${sessionId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                log(`ğŸ’“ Keepalive sent for main session ${sessionId}`);
            } catch (e) {
                log(`âŒ Keepalive error: ${e.message}`);
            }
        }

        function startKeepalive(sessionId) {
            stopKeepalive();
            if (!sessionId) return;
            state.keepaliveTimer = setInterval(() => sendKeepalive(sessionId), 30000);
            log(`â±ï¸ Keepalive started for main session ${sessionId}`);
        }

        function stopKeepalive() {
            if (state.keepaliveTimer) {
                clearInterval(state.keepaliveTimer);
                state.keepaliveTimer = null;
                log(`ğŸ›‘ Keepalive stopped`);
            }
        }

        // Initial log
        log('ğŸš€ Live Streaming Test Page Loaded');
        log('ğŸ“ Enter your access token and click "Save Tokens" to begin');
        log('ğŸ’¡ NEW ARCHITECTURE: 1 Session - Multiple Handles');
        log('ğŸ’¡ Join room first â†’ Then publish camera/screen â†’ All use same session!');
    </script>
</body>
</html>


