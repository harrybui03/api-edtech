<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Streaming Test</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .video-box {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        .video-box video {
            width: 100%;
            height: auto;
            display: block;
        }
        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .controls {
            margin-top: 10px;
        }
        .log-container {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
        }
        .btn-group-sm .btn {
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container py-4">
        <h1 class="mb-4">ğŸ¥ Live Streaming Test</h1>
        
        <!-- Login Section -->
        <div class="section" id="login-section">
            <h3>ğŸ” Authentication</h3>
            <div class="row g-3">
                <div class="col-md-5">
                    <label class="form-label">Access Token:</label>
                    <input type="text" id="accessToken" class="form-control" placeholder="Paste your access token">
                </div>
                <div class="col-md-5">
                    <label class="form-label">Refresh Token (optional):</label>
                    <input type="text" id="refreshToken" class="form-control" placeholder="Paste your refresh token">
                </div>
                <div class="col-md-2 d-flex align-items-end">
                    <button onclick="saveTokens()" class="btn btn-primary w-100">Save Tokens</button>
                </div>
            </div>
            <div class="mt-2">
                <small class="text-muted">Status: <span id="auth-status" class="badge bg-secondary">Not authenticated</span></small>
            </div>
        </div>

        <!-- Instructor Controls -->
        <div class="section">
            <h3>ğŸ‘¨â€ğŸ« Instructor Controls</h3>
            <div class="row g-3">
                <div class="col-md-4">
                    <label class="form-label">Batch ID:</label>
                    <input type="text" id="batchId" class="form-control" placeholder="Enter batch UUID">
                </div>
                <div class="col-md-3">
                    <label class="form-label">Title:</label>
                    <input type="text" id="liveTitle" class="form-control" value="Live Session Test">
                </div>
                <div class="col-md-5">
                    <label class="form-label">Description:</label>
                    <input type="text" id="liveDescription" class="form-control" value="Testing live streaming">
                </div>
            </div>
            <div class="controls">
                <button onclick="startLive()" class="btn btn-success">Start Live</button>
                <button onclick="endLive()" class="btn btn-danger">End Live</button>
            </div>
            <div class="mt-2">
                <small>Room ID: <strong id="roomId">-</strong></small>
            </div>
        </div>

        <!-- Join & Publish Section -->
        <div class="section">
            <h3>ğŸ“¹ Join Room & Publish Streams</h3>
            <div class="row g-3">
                <div class="col-md-6">
                    <label class="form-label">Room ID:</label>
                    <input type="text" id="joinRoomId" class="form-control" placeholder="Enter room ID">
                </div>
                <div class="col-md-6">
                    <label class="form-label">Your Name (optional):</label>
                    <input type="text" id="displayName" class="form-control" placeholder="Enter your name">
                </div>
            </div>
            
            <!-- Join Room Button -->
            <div class="controls mt-3">
                <button onclick="joinRoom()" class="btn btn-primary btn-lg">ğŸšª Join Room</button>
                <small class="ms-2">Session: <span id="sessionStatus" class="badge bg-secondary">Not joined</span></small>
            </div>
            
            <!-- Publish Buttons -->
            <div class="controls mt-3">
                <button onclick="publishCamera()" class="btn btn-success">ğŸ“¹ Publish Camera</button>
                <button onclick="publishScreen()" class="btn btn-info">ğŸ–¥ï¸ Publish Screen</button>
                <button onclick="toggleMic()" id="micBtn" class="btn btn-secondary">ğŸ¤ Mute Mic</button>
                <button onclick="unpublishCamera()" class="btn btn-warning" id="stopCameraBtn">â¹ï¸ Stop Camera</button>
                <button onclick="unpublishScreen()" class="btn btn-warning">â¹ï¸ Stop Screen</button>
            </div>
            
            <div class="mt-2">
                <small>Room: <strong id="currentRoomId">-</strong></small> | 
                <small>Session: <strong id="mainSessionId">-</strong></small> | 
                <small>Mic: <span id="micStatus" class="badge bg-success">ON</span></small>
            </div>
            <p class="text-muted mt-2 mb-0">
                <small>ğŸ’¡ <strong>Best practice:</strong> Join room first â†’ Then publish camera/screen</small><br>
                <small>ğŸ”¥ All operations (join, publish, subscribe) use the same session!</small>
            </p>
        </div>

        <!-- Recording Controls (Instructor) -->
        <div class="section">
            <h3>ğŸ¬ Recording Controls (Instructor)</h3>
            <div class="alert alert-info">
                <strong>ğŸ“ How it works:</strong> Records your screen + mic + system audio â†’ Creates 30-second chunks â†’ Auto-uploads to backend â†’ Backend merges & transcodes
            </div>
            <div class="controls">
                <button onclick="startRecording()" id="startRecBtn" class="btn btn-danger btn-lg">ğŸ”´ Start Recording</button>
                <button onclick="stopRecording()" id="stopRecBtn" class="btn btn-warning btn-lg" disabled>â¹ï¸ Stop Recording</button>
                <button onclick="checkRecordingStatus()" class="btn btn-info">ğŸ“Š Check Status</button>
            </div>
            <div class="mt-3">
                <div class="row">
                    <div class="col-md-3">
                        <small>Status: <span id="recStatus" class="badge bg-secondary">Not Started</span></small>
                    </div>
                    <div class="col-md-3">
                        <small>Duration: <strong id="recDuration">00:00</strong></small>
                    </div>
                    <div class="col-md-3">
                        <small>Chunks: <strong id="recChunks">0</strong></small>
                    </div>
                    <div class="col-md-3">
                        <small>Last Upload: <span id="recLastUpload">-</span></small>
                    </div>
                </div>
            </div>
            <div id="recordingProgress" class="mt-3" style="display:none;">
                <div class="progress">
                    <div id="uploadProgress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%">Uploading...</div>
                </div>
            </div>
            <div id="recordingResult" class="mt-3"></div>
        </div>

        <!-- Watch Others -->
        <div class="section">
            <h3>ğŸ‘€ Watch Others</h3>
            <div class="controls">
                <button onclick="listParticipants()" class="btn btn-primary">List Participants</button>
                <button onclick="subscribeToAll()" class="btn btn-success">Subscribe to All</button>
            </div>
            <div id="participantsList" class="mt-3"></div>
        </div>

        <!-- Video Display -->
        <div class="section">
            <h3>ğŸ“º Video Streams</h3>
            <div class="video-container" id="videoContainer">
                <!-- Videos will be added here dynamically -->
            </div>
        </div>

        <!-- Logs -->
        <div class="section">
            <h3>ğŸ“‹ Logs</h3>
            <div class="log-container" id="logContainer"></div>
            <button onclick="clearLogs()" class="btn btn-sm btn-secondary mt-2">Clear Logs</button>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000/api/v1';
        let accessToken = '';
        let refreshToken = '';
        
        // State management - NEW ARCHITECTURE: 1 Session - Multiple Handles
        let state = {
            roomId: null,
            mainSessionId: null,  // ğŸ”¥ ONE main session for all (join, publish, subscribe)
            // Peer connections
            cameraPc: null,
            cameraHandleId: null,
            screenPc: null,
            screenHandleId: null,
            subscriberPcs: {},
            subscriberHandles: {},  // Track subscriber handles
            publishers: [],
            keepaliveTimer: null,  // ğŸ”¥ ONE keepalive timer for main session
            micMuted: false,
            localStream: null,
            // Recording state
            recording: {
                mediaRecorder: null,
                combinedStream: null,
                chunkIndex: 0,
                isRecording: false,
                isStopping: false, // Flag to prevent restart on stop
                startTime: null,
                durationTimer: null,
                chunkTimer: null, // Timer for stop/restart every 30s
                totalDurationSeconds: 0,
                uploadedChunks: 0,
                screenStream: null,
                micStream: null,
                audioContext: null,
                roomId: null,
                isCompleting: false, // Flag to prevent duplicate complete API calls
                recordingOptions: null, // Store MediaRecorder options for restart
                recordingStream: null // Store stream for restart
            }
        };

        // ===== Authentication =====
        function saveTokens() {
            accessToken = document.getElementById('accessToken').value.trim();
            refreshToken = document.getElementById('refreshToken').value.trim();
            
            if (accessToken) {
                document.getElementById('auth-status').textContent = 'Authenticated';
                document.getElementById('auth-status').className = 'badge bg-success';
                log('âœ… Tokens saved successfully');
            } else {
                document.getElementById('auth-status').textContent = 'Not authenticated';
                document.getElementById('auth-status').className = 'badge bg-danger';
                log('âŒ Please enter access token');
            }
        }

        function getHeaders() {
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            };
        }

        // ===== Logging =====
        function log(message) {
            const logContainer = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            logContainer.innerHTML += `[${time}] ${message}\n`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('logContainer').innerHTML = '';
        }

        // ===== Video Management =====
        function addVideoElement(streamId, stream, label) {
            const container = document.getElementById('videoContainer');
            
            // Remove existing video if any
            const existing = document.getElementById(streamId);
            if (existing) {
                existing.remove();
            }
            
            const videoBox = document.createElement('div');
            videoBox.className = 'video-box';
            videoBox.id = streamId;
            
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsinline = true;
            video.muted = label.includes('Local'); // Mute local videos
            video.srcObject = stream;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'video-label';
            labelDiv.textContent = label;
            
            videoBox.appendChild(video);
            videoBox.appendChild(labelDiv);
            container.appendChild(videoBox);
            
            log(`ğŸ“¹ Added video: ${label}`);
        }

        function removeVideoElement(streamId) {
            const element = document.getElementById(streamId);
            if (element) {
                element.remove();
                log(`ğŸ—‘ï¸ Removed video: ${streamId}`);
            }
        }

        // ===== Start Live (Instructor) =====
        async function startLive() {
            const batchId = document.getElementById('batchId').value.trim();
            const title = document.getElementById('liveTitle').value.trim();
            const description = document.getElementById('liveDescription').value.trim();
            
            if (!batchId) {
                alert('Please enter batch ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/start`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ batchId, title, description })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    state.roomId = data.roomId;
                    document.getElementById('roomId').textContent = data.roomId;
                    document.getElementById('joinRoomId').value = data.roomId;
                    log(`âœ… Live started! Room ID: ${data.roomId}`);
                } else {
                    log(`âŒ Start live failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== End Live =====
        async function endLive() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/end/${roomId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`âœ… Live ended successfully`);
                } else {
                    log(`âŒ End live failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Join Room =====
        async function joinRoom() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            const displayName = document.getElementById('displayName').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const requestBody = { 
                    roomId: parseInt(roomId), 
                    ptype: 'publisher',  // Always join as publisher
                    displayName: displayName || undefined
                };
                
                const response = await fetch(`${API_BASE}/live/join`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // ğŸ”¥ Save main session ID - will be reused for ALL operations
                    state.mainSessionId = data.sessionId;
                    state.roomId = parseInt(roomId);
                    
                    // Update UI
                    document.getElementById('currentRoomId').textContent = roomId;
                    document.getElementById('mainSessionId').textContent = state.mainSessionId;
                    document.getElementById('sessionStatus').textContent = 'Joined âœ…';
                    document.getElementById('sessionStatus').className = 'badge bg-success';
                    
                    // Start keepalive for main session
                    startKeepalive(state.mainSessionId);
                    
                    const name = displayName || 'Anonymous';
                    log(`âœ… Joined room ${roomId} as publisher (${name})`);
                    log(`ğŸ”¥ Main session created: ${state.mainSessionId}`);
                    log(`ğŸ’¡ This session will be reused for camera, screen, and subscribe!`);
                } else {
                    log(`âŒ Join failed: ${JSON.stringify(data)}`);
                    document.getElementById('sessionStatus').textContent = 'Failed âŒ';
                    document.getElementById('sessionStatus').className = 'badge bg-danger';
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Publish Camera =====
        async function publishCamera() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                // Get camera stream
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                state.localStream = stream; // Save stream for mic control
                addVideoElement('local-camera', stream, 'Local Camera');
                
                // Create peer connection with ICE servers
                const pcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                state.cameraPc = new RTCPeerConnection(pcConfig);
                stream.getTracks().forEach(track => state.cameraPc.addTrack(track, stream));
                
                // Create offer
                const offer = await state.cameraPc.createOffer();
                await state.cameraPc.setLocalDescription(offer);
                
                // Wait for ICE gathering to complete
                if (state.cameraPc.iceGatheringState !== 'complete') {
                    log(`â³ Waiting for ICE gathering... (current state: ${state.cameraPc.iceGatheringState})`);
                    
                    // Log ICE candidates as they come in
                    state.cameraPc.onicecandidate = (event) => {
                        if (event.candidate) {
                            log(`ğŸ” ICE candidate: ${event.candidate.type} - ${event.candidate.address || event.candidate.candidate}`);
                        } else {
                            log('ğŸ” ICE gathering finished (null candidate)');
                        }
                    };
                    
                    await new Promise((resolve) => {
                        const checkState = () => {
                            if (state.cameraPc.iceGatheringState === 'complete') {
                                log(`âœ… ICE gathering complete (${state.cameraPc.iceGatheringState})`);
                                resolve();
                            }
                        };
                        state.cameraPc.addEventListener('icegatheringstatechange', checkState);
                        // Timeout after 5 seconds
                        setTimeout(() => {
                            state.cameraPc.removeEventListener('icegatheringstatechange', checkState);
                            log(`âš ï¸ ICE gathering timeout (state: ${state.cameraPc.iceGatheringState}), proceeding anyway`);
                            resolve();
                        }, 5000);
                    });
                } else {
                    log('âœ… ICE already complete');
                }
                
                // Use updated SDP with ICE candidates
                const finalOffer = state.cameraPc.localDescription;
                
                log('ğŸ“¤ Publishing camera stream...');
                log(`SDP Offer (first 200 chars): ${finalOffer.sdp.substring(0, 200)}...`);
                
                // Validate SDP doesn't have 0.0.0.0 (indicates no ICE candidates)
                if (finalOffer.sdp.includes('c=IN IP4 0.0.0.0')) {
                    log('âš ï¸ WARNING: SDP contains c=IN IP4 0.0.0.0 - ICE gathering may have failed!');
                    log('âš ï¸ This will cause Janus to reject the offer with error 490');
                    
                    // Try to proceed anyway, but warn user
                    const proceed = confirm('SDP has no valid ICE candidates (0.0.0.0). Try anyway?');
                    if (!proceed) {
                        log('âŒ Publish cancelled by user');
                        return;
                    }
                }
                
                // Check for valid ICE candidates in SDP
                const hasCandidates = finalOffer.sdp.includes('a=candidate:');
                log(`ğŸ“Š SDP has ICE candidates: ${hasCandidates}`);
                
                // ğŸ”¥ Send to backend (backend auto-detects sessionId/handleId from DB!)
                const publishPayload = { 
                    roomId: parseInt(roomId), 
                    sdp: finalOffer.sdp,  // Use final SDP with ICE candidates
                    streamType: 'camera'
                };
                
                log('âœ… Sending publish request (backend creates new session automatically)');
                
                // Update current room ID display
                document.getElementById('currentRoomId').textContent = roomId;
                
                const response = await fetch(`${API_BASE}/live/publish`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify(publishPayload)
                });
                
                const data = await response.json();
                
                if (response.ok && data.sdpAnswer) {
                    log('ğŸ“¥ Received SDP answer from server');
                    log(`SDP Answer (first 200 chars): ${data.sdpAnswer.substring(0, 200)}...`);
                    
                    // ğŸ”¥ Save camera handle (session is main session, already tracked)
                    if (data.sessionId && data.handleId) {
                        // Verify sessionId matches main session
                        if (state.mainSessionId && data.sessionId !== state.mainSessionId) {
                            log(`âš ï¸ Warning: Camera session ${data.sessionId} differs from main ${state.mainSessionId}`);
                        }
                        state.mainSessionId = data.sessionId;  // Ensure we have it
                        state.cameraHandleId = data.handleId;
                        log(`âœ… Camera published: session ${state.mainSessionId}, handle: ${state.cameraHandleId}`);
                    } else {
                        log('âš ï¸ Backend did not return sessionId/handleId in response');
                    }
                    
                    // Check if SDP contains ICE candidates
                    if (data.sdpAnswer.includes('c=IN IP4 0.0.0.0')) {
                        log('âš ï¸ WARNING: SDP answer contains 0.0.0.0 - may have ICE issues');
                    }
                    
                    // Check peer connection state before setting remote description
                    log(`ğŸ“Š PeerConnection state before setRemoteDescription: ${state.cameraPc.signalingState}`);
                    
                    if (state.cameraPc.signalingState !== 'have-local-offer') {
                        log(`âŒ Invalid signaling state: ${state.cameraPc.signalingState}. Expected: have-local-offer`);
                        throw new Error(`Cannot set remote answer in state: ${state.cameraPc.signalingState}`);
                    }
                    
                    try {
                        await state.cameraPc.setRemoteDescription(new RTCSessionDescription({
                            type: 'answer',
                            sdp: data.sdpAnswer
                        }));
                        log('âœ… Remote description set successfully');
                        log(`ğŸ“Š PeerConnection state after: ${state.cameraPc.signalingState}`);
                        log('âœ… Camera published successfully');
                    } catch (setRemoteError) {
                        log(`âŒ Error setting remote description: ${setRemoteError.message}`);
                        log(`SDP Answer that caused error: ${data.sdpAnswer}`);
                        throw setRemoteError;
                    }
                } else if (data.error) {
                    log(`âŒ Publish failed - Server error: ${data.error} (code: ${data.errorCode})`);
                    if (data.errorCode === 490) {
                        log('ğŸ’¡ ICE error 490 - This usually means:');
                        log('   1. SDP offer has invalid ICE candidates');
                        log('   2. SDP contains c=IN IP4 0.0.0.0');
                        log('   3. STUN servers are not working');
                        log('   Check your SDP offer above for 0.0.0.0 addresses');
                    }
                } else {
                    log(`âŒ Publish failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Publish Screen =====
        async function publishScreen() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                // Get screen stream
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                addVideoElement('local-screen', stream, 'Local Screen');
                
                // Handle when user stops sharing
                stream.getVideoTracks()[0].onended = () => {
                    log('âš ï¸ Screen sharing stopped by user');
                    unpublishScreen();
                };
                
                // Create peer connection with ICE servers
                const pcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                state.screenPc = new RTCPeerConnection(pcConfig);
                stream.getTracks().forEach(track => state.screenPc.addTrack(track, stream));
                
                // Create offer
                const offer = await state.screenPc.createOffer();
                await state.screenPc.setLocalDescription(offer);
                
                // Wait for ICE gathering to complete
                if (state.screenPc.iceGatheringState !== 'complete') {
                    log(`â³ Waiting for ICE gathering... (current state: ${state.screenPc.iceGatheringState})`);
                    
                    // Log ICE candidates as they come in
                    state.screenPc.onicecandidate = (event) => {
                        if (event.candidate) {
                            log(`ğŸ” ICE candidate: ${event.candidate.type} - ${event.candidate.address || event.candidate.candidate}`);
                        } else {
                            log('ğŸ” ICE gathering finished (null candidate)');
                        }
                    };
                    
                    await new Promise((resolve) => {
                        const checkState = () => {
                            if (state.screenPc.iceGatheringState === 'complete') {
                                log(`âœ… ICE gathering complete (${state.screenPc.iceGatheringState})`);
                                resolve();
                            }
                        };
                        state.screenPc.addEventListener('icegatheringstatechange', checkState);
                        // Timeout after 5 seconds
                        setTimeout(() => {
                            state.screenPc.removeEventListener('icegatheringstatechange', checkState);
                            log(`âš ï¸ ICE gathering timeout (state: ${state.screenPc.iceGatheringState}), proceeding anyway`);
                            resolve();
                        }, 5000);
                    });
                } else {
                    log('âœ… ICE already complete');
                }
                
                // Use updated SDP with ICE candidates
                const finalOffer = state.screenPc.localDescription;
                
                log('ğŸ“¤ Publishing screen share...');
                log(`SDP Offer (first 200 chars): ${finalOffer.sdp.substring(0, 200)}...`);
                
                // Send to backend
                const response = await fetch(`${API_BASE}/live/publish-screen`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ roomId: parseInt(roomId), sdp: finalOffer.sdp })
                });
                
                const data = await response.json();
                
                if (response.ok && data.sdpAnswer) {
                    // ğŸ”¥ Save screen handle (session is main session, already tracked)
                    if (data.sessionId && data.handleId) {
                        // Verify sessionId matches main session
                        if (state.mainSessionId && data.sessionId !== state.mainSessionId) {
                            log(`âš ï¸ Warning: Screen session ${data.sessionId} differs from main ${state.mainSessionId}`);
                        }
                        state.mainSessionId = data.sessionId;  // Ensure we have it
                        state.screenHandleId = data.handleId;
                    }
                    
                    await state.screenPc.setRemoteDescription(new RTCSessionDescription({
                        type: 'answer',
                        sdp: data.sdpAnswer
                    }));
                    log(`âœ… Screen published successfully. Session: ${state.mainSessionId}, Handle: ${state.screenHandleId}`);
                } else {
                    log(`âŒ Publish screen failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Unpublish Camera =====
        async function unpublishCamera() {
            console.log('ğŸ”´ unpublishCamera() called!'); // Debug
            log('ğŸ”´ unpublishCamera button clicked');
            
            const roomId = document.getElementById('joinRoomId').value.trim();
            log(`ğŸ” Room ID from input: "${roomId}"`);
            
            if (!roomId) {
                const msg = 'Please enter room ID';
                alert(msg);
                log(`âŒ Validation failed: ${msg}`);
                return;
            }
            
            try {
                log('ğŸ›‘ Stopping camera...');
                
                // Step 1: Stop ALL local stream tracks FIRST (this turns off camera LED)
                if (state.localStream) {
                    log('   Stopping local stream tracks...');
                    state.localStream.getTracks().forEach(track => {
                        log(`   - Stopping ${track.kind} track (id: ${track.id})`);
                        track.stop();
                    });
                    state.localStream = null;
                }
                
                // Step 2: Stop tracks from peer connection senders
                if (state.cameraPc) {
                    log('   Stopping peer connection senders...');
                    state.cameraPc.getSenders().forEach(sender => {
                        if (sender.track) {
                            log(`   - Stopping sender ${sender.track.kind} track`);
                            sender.track.stop();
                        }
                    });
                    
                    // Step 3: Close peer connection
                    log('   Closing peer connection...');
                    state.cameraPc.close();
                    state.cameraPc = null;
                }
                
                // Step 4: Remove video element
                removeVideoElement('local-camera');
                
                // Step 5: Reset mic state
                state.micMuted = false;
                document.getElementById('micBtn').textContent = 'ğŸ¤ Mute Mic';
                document.getElementById('micBtn').className = 'btn btn-secondary';
                document.getElementById('micStatus').textContent = 'ON';
                document.getElementById('micStatus').className = 'badge bg-success';
                
                // Step 6: Notify backend (backend will destroy handle, keep session)
                log('   Notifying backend...');
                const response = await fetch(`${API_BASE}/live/unpublish/${roomId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                
                if (response.ok) {
                    log('âœ… Camera unpublished and stopped completely');
                    // Clear handle state (keep main session!)
                    state.cameraHandleId = null;
                } else {
                    const data = await response.json();
                    log(`âŒ Unpublish camera failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error in unpublishCamera: ${error.message}`);
                console.error('âŒ Unpublish error:', error);
                alert(`Error stopping camera: ${error.message}`);
            }
            
            console.log('ğŸ”´ unpublishCamera() finished');
        }

        // ===== Unpublish Screen =====
        async function unpublishScreen() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                log('ğŸ›‘ Stopping screen share...');
                
                // Stop all screen tracks
                if (state.screenPc) {
                    log('   Stopping screen peer connection...');
                    state.screenPc.getSenders().forEach(sender => {
                        if (sender.track) {
                            sender.track.stop();
                        }
                    });
                    state.screenPc.close();
                    state.screenPc = null;
                }
                
                // Remove video element
                removeVideoElement('local-screen');
                
                // Backend auto-detects screen session/handle from DB
                log('   Notifying backend...');
                const response = await fetch(`${API_BASE}/live/unpublish-screen/${roomId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                
                if (response.ok) {
                    log('âœ… Screen share unpublished and stopped completely');
                    // Clear handle state (keep main session!)
                    state.screenHandleId = null;
                } else {
                    const data = await response.json();
                    log(`âŒ Unpublish screen failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error in unpublishScreen: ${error.message}`);
                console.error('Unpublish screen error:', error);
            }
        }

        // ===== Toggle Microphone =====
        function toggleMic() {
            if (!state.localStream) {
                alert('Please publish camera first');
                log('âš ï¸ No local stream available. Publish camera first.');
                return;
            }
            
            const audioTracks = state.localStream.getAudioTracks();
            if (audioTracks.length === 0) {
                alert('No audio track found');
                log('âš ï¸ No audio track in local stream');
                return;
            }
            
            state.micMuted = !state.micMuted;
            audioTracks.forEach(track => {
                track.enabled = !state.micMuted;
            });
            
            // Update UI
            const micBtn = document.getElementById('micBtn');
            const micStatus = document.getElementById('micStatus');
            
            if (state.micMuted) {
                micBtn.textContent = 'ğŸ¤ Unmute Mic';
                micBtn.className = 'btn btn-danger';
                micStatus.textContent = 'OFF';
                micStatus.className = 'badge bg-danger';
                log('ğŸ”‡ Microphone muted');
            } else {
                micBtn.textContent = 'ğŸ¤ Mute Mic';
                micBtn.className = 'btn btn-secondary';
                micStatus.textContent = 'ON';
                micStatus.className = 'badge bg-success';
                log('ğŸ”Š Microphone unmuted');
            }
        }

        // ===== List Participants =====
        async function listParticipants() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                // Backend automatically filters out all YOUR feeds (camera + screen)
                // No need to manually exclude - it uses your auth token to identify you!
                const url = `${API_BASE}/live/participants/${roomId}`;
                
                const response = await fetch(url, {
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    state.publishers = data.participants.filter(p => p.publisher);
                    
                    const container = document.getElementById('participantsList');
                    container.innerHTML = '<h5>ğŸŒ Active Streams (Others):</h5>';
                    
                    if (state.publishers.length === 0) {
                        container.innerHTML += '<p class="text-muted">No one else is streaming</p>';
                    }
                    
                    state.publishers.forEach(p => {
                        // Identify feed type by display name
                        const isScreen = p.display && p.display.includes('(Screen)');
                        const icon = isScreen ? 'ğŸ–¥ï¸' : 'ğŸ“¹';
                        
                        container.innerHTML += `
                            <div class="alert alert-info">
                                ${icon} <strong>${p.display}</strong> (Feed ID: ${p.id})
                                <button onclick="subscribeToPublisher(${p.id}, '${p.display}')" class="btn btn-sm btn-primary float-end">Watch</button>
                            </div>
                        `;
                    });
                    
                    log(`âœ… Found ${state.publishers.length} active stream(s) from others (your feeds auto-excluded)`);
                } else {
                    log(`âŒ List participants failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }
        
        // ===== Get My Feeds (Optional - for debugging) =====
        async function getMyFeeds() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/live/my-feeds/${roomId}`, {
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`ğŸ“Š My Feeds: ${JSON.stringify(data.feeds, null, 2)}`);
                    
                    if (data.feeds && data.feeds.length > 0) {
                        log(`âœ… You have ${data.feeds.length} active feed(s):`);
                        data.feeds.forEach(feed => {
                            log(`   - ${feed.feedType}: Feed ID ${feed.feedId} (${feed.displayName})`);
                        });
                    } else {
                        log(`â„¹ï¸ You have no active feeds in this room`);
                    }
                } else {
                    log(`âŒ Get my feeds failed: ${JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Subscribe to Publisher =====
        async function subscribeToPublisher(feedId, displayName) {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                log(`Subscribing to ${displayName} (feed ${feedId})...`);
                
                // Step 1: Subscribe (backend will create new session/handle for this feed)
                const subscribeResponse = await fetch(`${API_BASE}/live/subscribe`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        roomId: parseInt(roomId),
                        feedId: feedId
                        // Note: No need to send sessionId/handleId, backend creates new ones
                    })
                });
                
                const subscribeData = await subscribeResponse.json();
                
                if (!subscribeResponse.ok || !subscribeData.sdpOffer) {
                    log(`Subscribe failed: ${JSON.stringify(subscribeData)}`);
                    return;
                }
                
                log(`Received SDP offer, new session: ${subscribeData.sessionId}, handle: ${subscribeData.handleId}`);
                
                // Step 2: Create peer connection with ICE servers
                const pcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                };
                const pc = new RTCPeerConnection(pcConfig);
                state.subscriberPcs[feedId] = pc;
                
                // Handle incoming stream
                pc.ontrack = (event) => {
                    log(`ğŸ¬ ontrack event! Track kind: ${event.track.kind}, streams: ${event.streams.length}`);
                    const [stream] = event.streams;
                    if (stream) {
                        log(`ğŸ“º Stream ID: ${stream.id}, tracks: ${stream.getTracks().length}`);
                        addVideoElement(`remote-${feedId}`, stream, `Remote: ${displayName}`);
                    } else {
                        log('âš ï¸ No stream in ontrack event!');
                    }
                };
                
                // Monitor ICE connection state
                pc.oniceconnectionstatechange = () => {
                    log(`ğŸ”Œ ICE connection state: ${pc.iceConnectionState}`);
                };
                
                pc.onconnectionstatechange = () => {
                    log(`ğŸ”— Connection state: ${pc.connectionState}`);
                };
                
                // Set remote description (SDP offer from Janus)
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'offer',
                    sdp: subscribeData.sdpOffer
                }));
                
                // Create answer
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                // Wait for ICE gathering to complete (like publisher)
                if (pc.iceGatheringState !== 'complete') {
                    log(`â³ Waiting for subscriber ICE gathering... (state: ${pc.iceGatheringState})`);
                    
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            log(`ğŸ” Subscriber ICE candidate: ${event.candidate.type}`);
                        } else {
                            log('ğŸ” Subscriber ICE gathering finished');
                        }
                    };
                    
                    await new Promise((resolve) => {
                        const checkState = () => {
                            if (pc.iceGatheringState === 'complete') {
                                log(`âœ… Subscriber ICE gathering complete`);
                                resolve();
                            }
                        };
                        pc.addEventListener('icegatheringstatechange', checkState);
                        setTimeout(() => {
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            log(`âš ï¸ Subscriber ICE timeout (state: ${pc.iceGatheringState}), proceeding`);
                            resolve();
                        }, 5000);
                    });
                } else {
                    log('âœ… Subscriber ICE already complete');
                }
                
                // Use final SDP with ICE candidates
                const finalAnswer = pc.localDescription;
                
                // Step 3: Start subscriber (send SDP answer)
                // Use the NEW sessionId and handleId returned from subscribe
                const startResponse = await fetch(`${API_BASE}/live/start-subscriber`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        sessionId: subscribeData.sessionId,  // Use new session
                        handleId: subscribeData.handleId,    // Use new handle
                        sdpAnswer: finalAnswer.sdp           // Use final SDP with ICE
                    })
                });
                
                if (startResponse.ok) {
                    log(`âœ… Subscribed to ${displayName} successfully`);
                    
                    // ğŸ”¥ Verify subscriber reuses main session
                    if (state.mainSessionId && subscribeData.sessionId !== state.mainSessionId) {
                        log(`âš ï¸ Warning: Subscriber session ${subscribeData.sessionId} differs from main ${state.mainSessionId}`);
                    }
                    state.mainSessionId = subscribeData.sessionId;  // Ensure we have it
                    
                    // Store handle for this feed
                    state.subscriberHandles[feedId] = subscribeData.handleId;
                } else {
                    log(`âŒ Start subscriber failed`);
                }
            } catch (error) {
                log(`âŒ Error: ${error.message}`);
            }
        }

        // ===== Subscribe to All Publishers =====
        async function subscribeToAll() {
            if (state.publishers.length === 0) {
                alert('Please list participants first');
                return;
            }
            
            for (const publisher of state.publishers) {
                await subscribeToPublisher(publisher.id, publisher.display);
                await new Promise(resolve => setTimeout(resolve, 1000)); // Delay between subscriptions
            }
        }

        // ===== Keepalive helpers - ONE timer for main session =====
        async function sendKeepalive(sessionId) {
            try {
                await fetch(`${API_BASE}/live/keepalive/${sessionId}`, {
                    method: 'POST',
                    headers: getHeaders()
                });
                log(`ğŸ’“ Keepalive sent for main session ${sessionId}`);
            } catch (e) {
                log(`âŒ Keepalive error: ${e.message}`);
            }
        }

        function startKeepalive(sessionId) {
            stopKeepalive();
            if (!sessionId) return;
            state.keepaliveTimer = setInterval(() => sendKeepalive(sessionId), 30000);
            log(`â±ï¸ Keepalive started for main session ${sessionId}`);
        }

        function stopKeepalive() {
            if (state.keepaliveTimer) {
                clearInterval(state.keepaliveTimer);
                state.keepaliveTimer = null;
                log(`ğŸ›‘ Keepalive stopped`);
            }
        }

        // ==================== RECORDING FUNCTIONS ====================
        
        /**
         * Start Recording - Merge screen + mic + system audio
         * â­ SIMPLIFIED VERSION: Uses timeslice for automatic chunking (30s)
         */
        async function startRecording() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID first');
                return;
            }
            
            try {
                log('ğŸ¬ Starting recording...');
                updateRecStatus('Initializing...', 'warning');
                
                // 1. Get screen stream with system audio
                log('ğŸ“º Requesting screen share with audio...');
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { 
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    },
                    audio: true // System audio
                });
                
                state.recording.screenStream = screenStream;
                
                // Handle when user stops sharing via browser button
                screenStream.getVideoTracks()[0].onended = () => {
                    log('âš ï¸ Screen sharing stopped by user');
                    stopRecording();
                };
                
                // 2. Get microphone stream
                log('ğŸ¤ Requesting microphone access...');
                const micStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                state.recording.micStream = micStream;
                
                // 3. Merge audio tracks using Web Audio API
                log('ğŸµ Merging audio tracks...');
                const audioContext = new AudioContext();
                state.recording.audioContext = audioContext;
                
                const destination = audioContext.createMediaStreamDestination();
                
                // Add screen audio if available
                const screenAudioTracks = screenStream.getAudioTracks();
                if (screenAudioTracks.length > 0) {
                    const screenAudioSource = audioContext.createMediaStreamSource(
                        new MediaStream(screenAudioTracks)
                    );
                    screenAudioSource.connect(destination);
                    log('âœ… System audio added');
                } else {
                    log('âš ï¸ No system audio in screen share');
                }
                
                // Add microphone audio
                const micAudioSource = audioContext.createMediaStreamSource(micStream);
                micAudioSource.connect(destination);
                log('âœ… Microphone added');
                
                // 4. Create combined stream: screen video + merged audio
                const combinedStream = new MediaStream([
                    ...screenStream.getVideoTracks(),
                    ...destination.stream.getAudioTracks()
                ]);
                
                state.recording.combinedStream = combinedStream;
                log(`âœ… Combined stream created: ${combinedStream.getTracks().length} tracks`);
                
                // 5. Setup MediaRecorder with WebM format
                // â­ USE VP8 instead of VP9 for better chunk stability
                // VP8 creates chunks with complete headers, VP9 metadata is distributed â†’ chunks after first may be corrupted
                const options = {
                    mimeType: 'video/webm;codecs=vp8,opus',
                    videoBitsPerSecond: 2500000, // 2.5 Mbps
                    audioBitsPerSecond: 128000  // 128 kbps for audio
                };
                
                // Verify codec support
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    throw new Error(`MediaRecorder does not support ${options.mimeType}`);
                }
                
                log('âœ… Using VP8 codec for stable chunk recording');
                
                // 6. Store options and stream for restart
                state.recording.recordingOptions = options;
                state.recording.recordingStream = combinedStream;
                
                // 7. Function to create and setup MediaRecorder
                function createMediaRecorder() {
                    // Use stored stream and options for restart capability
                    const stream = state.recording.recordingStream || combinedStream;
                    const opts = state.recording.recordingOptions || options;
                    const mr = new MediaRecorder(stream, opts);
                    
                    mr.ondataavailable = async (event) => {
                        if (!event.data || event.data.size < 1000) {
                            log(`âš ï¸ Chunk ${state.recording.chunkIndex} has no data or size is 0, skipping...`);
                            return;
                        }
                        
                        const blob = event.data;
                        const currentChunkIndex = state.recording.chunkIndex;
                        const duration = 30; // Each chunk is exactly 30s
                        
                        log(`ğŸ“¦ Chunk ${currentChunkIndex} ready (${(blob.size / 1024 / 1024).toFixed(2)} MB, ~30s)`);
                        
                        // Upload chunk immediately
                        try {
                            await uploadChunk(roomId, currentChunkIndex, blob, duration);
                            // CRITICAL: Only increment chunkIndex AFTER successful upload
                            state.recording.chunkIndex++;
                            state.recording.uploadedChunks++;
                            log(`âœ… Chunk ${currentChunkIndex} uploaded successfully (total: ${state.recording.uploadedChunks})`);
                        } catch (error) {
                            log(`âŒ Failed to upload chunk ${currentChunkIndex}: ${error.message}`);
                            // Don't increment chunkIndex on failure
                            // Continue recording even if one chunk fails
                        }
                    };
                    
                    mr.onerror = (event) => {
                        log(`âŒ MediaRecorder error: ${event.error}`);
                        updateRecStatus('Error', 'danger');
                    };
                    
                    mr.onstop = async () => {
                        log(`ğŸ›‘ MediaRecorder stopped (chunk ${state.recording.chunkIndex} complete)`);
                        
                        // CRITICAL: Check if we're stopping - don't restart if user clicked stop
                        if (state.recording.isStopping || !state.recording.isRecording) {
                            log('ğŸ›‘ Recording is stopping, NOT restarting MediaRecorder');
                            return; // Exit early - don't restart
                        }
                        
                        // Wait a bit for final data
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Double check: Restart recording ONLY if still active and NOT stopping
                        if (state.recording.isRecording && !state.recording.isStopping) {
                            log(`ğŸ”„ Restarting MediaRecorder for next chunk...`);
                            
                            try {
                                // Create new MediaRecorder to ensure clean state
                                const newMediaRecorder = createMediaRecorder();
                                state.recording.mediaRecorder = newMediaRecorder;
                                newMediaRecorder.start(); // Start without timeslice - creates complete WebM file
                                
                                log(`âœ… MediaRecorder restarted for chunk ${state.recording.chunkIndex}`);
                            } catch (error) {
                                log(`âŒ Failed to restart MediaRecorder: ${error.message}`);
                                stopRecording();
                            }
                        } else {
                            log('âš ï¸ Not restarting: isRecording=' + state.recording.isRecording + ', isStopping=' + state.recording.isStopping);
                        }
                    };
                    
                    return mr;
                }
                
                // 8. Create initial MediaRecorder
                const mediaRecorder = createMediaRecorder();
                state.recording.mediaRecorder = mediaRecorder;
                
                // 9. Start recording WITHOUT timeslice - creates complete WebM file
                mediaRecorder.start(); // No timeslice - creates complete WebM file
                log(`âœ… MediaRecorder started (will stop/restart every 30s for complete chunks)`);
                
                // 10. Set timer to stop/restart every 30 seconds
                state.recording.chunkTimer = setInterval(() => {
                    if (state.recording.isRecording && state.recording.mediaRecorder && !state.recording.isStopping) {
                        const mrState = state.recording.mediaRecorder.state;
                        if (mrState === 'recording') {
                            log(`â° 30s elapsed, stopping MediaRecorder to create complete chunk...`);
                            state.recording.mediaRecorder.stop(); // This will trigger onstop and restart
                        } else {
                            log(`âš ï¸ MediaRecorder state is ${mrState}, not stopping`);
                        }
                    }
                }, 30000); // 30 seconds
                
                // Initialize state
                state.recording.isRecording = true;
                state.recording.isStopping = false; // Flag to prevent restart on stop
                state.recording.startTime = Date.now();
                state.recording.chunkIndex = 0;
                state.recording.uploadedChunks = 0;
                state.recording.roomId = roomId;
                state.recording.isCompleting = false; // Reset flag
                
                // Update UI
                document.getElementById('startRecBtn').disabled = true;
                document.getElementById('stopRecBtn').disabled = false;
                updateRecStatus('Recording...', 'danger');
                
                // Start duration timer
                startDurationTimer();
                
                log('âœ… Recording started! MediaRecorder will stop/restart every 30s');
                log('ğŸ’¡ Each chunk is a complete WebM file with header - can play independently');
                log('ğŸ’¡ Keep this tab active for best recording quality');
                
            } catch (error) {
                log(`âŒ Failed to start recording: ${error.message}`);
                updateRecStatus('Failed', 'danger');
                alert(`Failed to start recording: ${error.message}\n\nMake sure you:\n1. Allow screen sharing\n2. Allow microphone access\n3. Check "Share audio" in screen share dialog`);
                cleanupRecording();
            }
        }
        
        /**
         * Stop Recording
         * â­ SIMPLIFIED VERSION: Stop recorder â†’ wait for final chunk â†’ call complete API
         */
        async function stopRecording() {
            if (!state.recording.isRecording) {
                alert('Recording not started');
                return;
            }
            
            // Prevent duplicate calls
            if (state.recording.isCompleting) {
                log('âš ï¸ Already completing recording, ignoring duplicate call');
                return;
            }
            
            try {
                log('ğŸ›‘ Stopping recording...');
                updateRecStatus('Stopping...', 'warning');
                
                // Set flags
                state.recording.isStopping = true; // Prevent restart in onstop
                state.recording.isRecording = false;
                state.recording.isCompleting = true; // Prevent duplicate complete API calls
                
                // Stop chunk timer FIRST to prevent timer from triggering
                if (state.recording.chunkTimer) {
                    clearInterval(state.recording.chunkTimer);
                    state.recording.chunkTimer = null;
                    log('â° Chunk timer stopped');
                }
                
                // Wait a bit to ensure timer callback doesn't fire
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Stop MediaRecorder - will fire ondataavailable with final chunk
                if (state.recording.mediaRecorder && state.recording.mediaRecorder.state !== 'inactive') {
                    log('ğŸ“¤ Stopping MediaRecorder (will trigger final chunk)...');
                    state.recording.mediaRecorder.stop();
                }
                
                // Wait for final chunk to be uploaded (ondataavailable will handle it)
                log('â³ Waiting for final chunk to be uploaded...');
                await waitForFinalChunk();
                
                // Calculate total duration
                const totalDurationSeconds = Math.floor((Date.now() - state.recording.startTime) / 1000);
                state.recording.totalDurationSeconds = totalDurationSeconds;
                
                const roomId = state.recording.roomId || document.getElementById('joinRoomId').value.trim();
                // CRITICAL: Use uploadedChunks (actual uploaded count) not chunkIndex
                const totalChunks = state.recording.uploadedChunks;
                
                if (!roomId) {
                    log(`âŒ Cannot complete: roomId is empty`);
                    throw new Error('Room ID is required to complete recording');
                }
                
                if (totalChunks === 0) {
                    log(`âš ï¸ Warning: No chunks uploaded (${totalChunks}). Still calling complete API...`);
                }
                
                log(`ğŸ“¤ Completing recording...`);
                log(`   Room ID: ${roomId}`);
                log(`   Total Chunks (uploaded): ${totalChunks}`);
                log(`   Chunk Index (next would be): ${state.recording.chunkIndex}`);
                log(`   Total Duration: ${totalDurationSeconds}s`);
                
                // Call complete API (only once)
                const response = await fetch(`${API_BASE}/live/recording/complete`, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({
                        roomId: parseInt(roomId),
                        totalChunks: totalChunks, // Use actual uploaded count
                        totalDurationSeconds: totalDurationSeconds
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    log(`âŒ Complete API failed: ${response.status} - ${errorText}`);
                    throw new Error(`Complete API failed: ${response.status} - ${errorText}`);
                }
                
                const data = await response.json();
                log(`âœ… Complete API response: ${JSON.stringify(data)}`);
                
                log('âœ… Recording completed! Backend is processing...');
                updateRecStatus('Processing...', 'info');
                document.getElementById('recordingResult').innerHTML = `
                    <div class="alert alert-success">
                        <strong>âœ… Recording Complete!</strong><br>
                        Total Duration: ${formatDuration(totalDurationSeconds)}<br>
                        Total Chunks: ${totalChunks}<br>
                        Status: ${data.status}<br>
                        <small class="text-muted">${data.message}</small>
                    </div>
                `;
                
                // Auto-check status after 5 seconds
                setTimeout(() => {
                    log('ğŸ”„ Auto-checking recording status...');
                    checkRecordingStatus();
                }, 5000);
                
                // Cleanup
                cleanupRecording();
                
            } catch (error) {
                log(`âŒ Error stopping recording: ${error.message}`);
                console.error('âŒ Stop recording error:', error);
                updateRecStatus('Error', 'danger');
                
                // Don't call complete API again in catch block - already handled above
                // Just cleanup
                cleanupRecording();
            }
        }
        
        /**
         * Wait for final chunk to be uploaded
         * Simple delay to ensure ondataavailable has fired and uploaded the final chunk
         */
        function waitForFinalChunk() {
            return new Promise((resolve) => setTimeout(resolve, 1500));
        }
        
        /**
         * Upload a single chunk to backend
         */
        async function uploadChunk(roomId, chunkIndex, blob, durationSeconds) {
            try {
                // Validate blob before upload
                if (!blob || blob.size === 0) {
                    log(`âš ï¸ Chunk ${chunkIndex} is empty, skipping upload`);
                    return;
                }
                
                if (blob.size < 1000) {
                    log(`âš ï¸ Chunk ${chunkIndex} is too small (${blob.size} bytes), may be corrupt`);
                }
                
                log(`ğŸ“¤ Uploading chunk ${chunkIndex} (${(blob.size / 1024 / 1024).toFixed(2)} MB)...`);
                document.getElementById('recordingProgress').style.display = 'block';
                document.getElementById('uploadProgress').style.width = '50%';
                
                // â­ CRITICAL: DO NOT wrap blob - it breaks WebM structure!
                // Wrapping blob destroys metadata/header layout â†’ chunks after first won't play
                // Use original blob directly from MediaRecorder
                const formData = new FormData();
                formData.append('file', blob, `chunk_${String(chunkIndex).padStart(3, '0')}.webm`);
                
                const url = `${API_BASE}/live/recording/upload-chunk?roomId=${roomId}&chunkIndex=${chunkIndex}&durationSeconds=${durationSeconds}`;
                
                // Upload with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000); // 60s timeout
                
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        },
                        body: formData,
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        log(`âœ… Chunk ${chunkIndex} uploaded successfully (${data.totalChunksUploaded} total)`);
                        state.recording.uploadedChunks = data.totalChunksUploaded;
                        document.getElementById('recChunks').textContent = data.totalChunksUploaded;
                        document.getElementById('recLastUpload').textContent = new Date().toLocaleTimeString();
                        document.getElementById('uploadProgress').style.width = '100%';
                        
                        setTimeout(() => {
                            document.getElementById('recordingProgress').style.display = 'none';
                            document.getElementById('uploadProgress').style.width = '0%';
                        }, 1000);
                    } else {
                        log(`âŒ Failed to upload chunk ${chunkIndex}: ${JSON.stringify(data)}`);
                        throw new Error(`Upload failed: ${data.message || 'Unknown error'}`);
                    }
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    if (fetchError.name === 'AbortError') {
                        throw new Error('Upload timeout after 60 seconds');
                    }
                    throw fetchError;
                }
                
            } catch (error) {
                log(`âŒ Error uploading chunk ${chunkIndex}: ${error.message}`);
                // Don't throw - continue recording even if one chunk fails
                document.getElementById('recordingProgress').style.display = 'none';
                throw error; // Re-throw so caller knows it failed
            }
        }
        
        /**
         * Check recording status
         */
        async function checkRecordingStatus() {
            const roomId = document.getElementById('joinRoomId').value.trim();
            
            if (!roomId) {
                alert('Please enter room ID');
                return;
            }
            
            try {
                log('ğŸ“Š Checking recording status...');
                
                const response = await fetch(`${API_BASE}/live/recording/status/${roomId}`, {
                    headers: getHeaders()
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    log(`âœ… Status: ${data.status} - ${data.message}`);
                    
                    updateRecStatus(data.status, getStatusBadgeClass(data.status));
                    
                    let resultHtml = `
                        <div class="alert alert-${getStatusAlertClass(data.status)}">
                            <strong>ğŸ“Š Recording Status</strong><br>
                            Status: <span class="badge bg-${getStatusBadgeClass(data.status)}">${data.status}</span><br>
                            Message: ${data.message}<br>
                    `;
                    
                    if (data.totalChunks) {
                        resultHtml += `Total Chunks: ${data.totalChunks}<br>`;
                    }
                    if (data.durationSeconds) {
                        resultHtml += `Duration: ${formatDuration(data.durationSeconds)}<br>`;
                    }
                    if (data.videoUrl) {
                        resultHtml += `
                            <hr>
                            <strong>ğŸ¥ Recording Ready!</strong><br>
                            <a href="${data.videoUrl}" target="_blank" class="btn btn-success mt-2">
                                ğŸ“¥ Download Video
                            </a>
                            <button onclick="openVideoInNewTab('${data.videoUrl}')" class="btn btn-primary mt-2">
                                â–¶ï¸ Play Video
                            </button>
                        `;
                    }
                    
                    resultHtml += '</div>';
                    document.getElementById('recordingResult').innerHTML = resultHtml;
                    
                } else {
                    log(`âŒ Failed to get status: ${JSON.stringify(data)}`);
                }
                
            } catch (error) {
                log(`âŒ Error checking status: ${error.message}`);
            }
        }
        
        /**
         * Open video in new tab
         */
        function openVideoInNewTab(url) {
            window.open(url, '_blank');
        }
        
        /**
         * Cleanup recording resources
         */
        function cleanupRecording() {
            // Stop all tracks
            if (state.recording.screenStream) {
                state.recording.screenStream.getTracks().forEach(track => track.stop());
            }
            if (state.recording.micStream) {
                state.recording.micStream.getTracks().forEach(track => track.stop());
            }
            if (state.recording.combinedStream) {
                state.recording.combinedStream.getTracks().forEach(track => track.stop());
            }
            
            // Close audio context
            if (state.recording.audioContext) {
                state.recording.audioContext.close();
            }
            
            // Stop duration timer
            if (state.recording.durationTimer) {
                clearInterval(state.recording.durationTimer);
            }
            
            // Stop chunk timer
            if (state.recording.chunkTimer) {
                clearInterval(state.recording.chunkTimer);
            }
            
            // Reset state
            state.recording = {
                mediaRecorder: null,
                combinedStream: null,
                chunkIndex: 0,
                isRecording: false,
                isStopping: false,
                startTime: null,
                durationTimer: null,
                chunkTimer: null,
                totalDurationSeconds: 0,
                uploadedChunks: 0,
                screenStream: null,
                micStream: null,
                audioContext: null,
                roomId: null,
                isCompleting: false,
                recordingOptions: null,
                recordingStream: null
            };
            
            // Reset UI
            document.getElementById('startRecBtn').disabled = false;
            document.getElementById('stopRecBtn').disabled = true;
            document.getElementById('recDuration').textContent = '00:00';
            document.getElementById('recChunks').textContent = '0';
        }
        
        /**
         * Start duration timer
         */
        function startDurationTimer() {
            state.recording.durationTimer = setInterval(() => {
                if (state.recording.startTime) {
                    const seconds = Math.floor((Date.now() - state.recording.startTime) / 1000);
                    document.getElementById('recDuration').textContent = formatDuration(seconds);
                }
            }, 1000);
        }
        
        /**
         * Format duration (seconds to MM:SS)
         */
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        /**
         * Update recording status badge
         */
        function updateRecStatus(status, badgeClass) {
            const badge = document.getElementById('recStatus');
            badge.textContent = status;
            badge.className = `badge bg-${badgeClass}`;
        }
        
        /**
         * Get badge class for status
         */
        function getStatusBadgeClass(status) {
            switch (status) {
                case 'NOT_STARTED': return 'secondary';
                case 'RECORDING': return 'danger';
                case 'PROCESSING': return 'info';
                case 'COMPLETED': return 'success';
                case 'FAILED': return 'danger';
                default: return 'secondary';
            }
        }
        
        /**
         * Get alert class for status
         */
        function getStatusAlertClass(status) {
            switch (status) {
                case 'COMPLETED': return 'success';
                case 'PROCESSING': return 'info';
                case 'RECORDING': return 'warning';
                case 'FAILED': return 'danger';
                default: return 'info';
            }
        }
        
        // ==================== END RECORDING FUNCTIONS ====================

        // Initial log
        log('ğŸš€ Live Streaming Test Page Loaded');
        log('ğŸ“ Enter your access token and click "Save Tokens" to begin');
        log('ğŸ’¡ NEW ARCHITECTURE: 1 Session - Multiple Handles');
        log('ğŸ’¡ Join room first â†’ Then publish camera/screen â†’ All use same session!');
        log('ğŸ¬ Recording: Stop/restart every 30s - Each chunk is complete WebM file with header');
    </script>
</body>
</html>


